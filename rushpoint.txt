local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local UserInputService = game:GetService('UserInputService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
ThemeManager:SetFolder('RushPointX')
SaveManager:SetFolder('RushPointX')
ThemeManager:SaveDefault('Tokyo Night')
local camera = Workspace.CurrentCamera
local players = Players
local LocalPlayer = players.LocalPlayer

local network = require(ReplicatedStorage.Modules.Shared.Network)
local recoil = require(ReplicatedStorage.Modules.Client.Helpers.RecoilHandler)
local bac_characters_senv = getsenv(game.ReplicatedStorage.BAC.Characters)
local KillAllEnabled = false
local Config = {
    HitPart = 'Head',
    TeamCheck = true,
    FOVColor = Color3.fromRGB(255, 255, 255),
    SilentAimFOVRadius = 100,
    AimbotFOVRadius = 100,
    FlySpeed = 50,
    AimbotSmoothing = 0,
    SkeletonESPColor = Color3.new(0, 0.25, 0.75),
    TracerOrigin = 'Bottom Screen',
    WalkSpeed = 16,
    JumpPower = 50,
}

local ESPSettings = {
    BoxEnabled = true,
    BoxColor = Color3.new(0, 0.25, 0.75),
}

local State = {
    ESPDistance = 500,
    SilentAimEnabled = false,
    SilentAimFOVEnabled = false,
    ESPCustomEnabled = false,
    NameESPEnabled = false,
    DistanceESPEnabled = false,
    SkeletonESPEnabled = false,
    HealthESPEnabled = false,
    TracerESPEnabled = false,
    FlyEnabled = false,
    NoclipEnabled = false,
    InfiniteJumpEnabled = false,
    AimbotEnabled = false,
    AimbotFOVEnabled = false,
    AimbotLocking = false,
    NoRecoilEnabled = false,
    WalkSpeedEnabled = false,
    JumpPowerEnabled = false,
    SilentAimFOVCircle = nil,
    AimbotFOVCircle = nil,
    OriginalGravity = nil,
    FlyConnection = nil,
    FlyReinitializeConnection = nil,
    FollowConnection = nil,
    FollowTarget = nil,
    SpectateConnection = nil,
    SpectateTarget = nil,
    SpectateEnabled = false,
}

local Caches = {
    ESPCache = {},
    SkeletonCache = {},
    HealthCache = {},
    TracerCache = {},
}

local SessionID = string.gsub(tostring(math.random()):sub(3), '%d', function(c)
    return string.char(96 + math.random(1, 26))
end)

-- Silent Aim Implementation (Unchanged)
local function GetClosestPlayer(fovRadius)
    local dist, target = math.huge, nil

    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild(Config.HitPart) then
                local position, on_screen = camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
                if on_screen then
                    local center = UserInputService:GetMouseLocation()
                    local distance = (center - Vector2.new(position.X, position.Y)).Magnitude
                    if distance <= fovRadius then
                        local mag = (character.HumanoidRootPart.CFrame.p - camera.CFrame.p).Magnitude
                        if mag < dist and mag <= State.ESPDistance then
                            dist = mag
                            target = character
                        end
                    end
                end
            end
        end
    end

    return target
end

local firesever_new = function(self, name, args)
    if name == 'FireBullet' and State.SilentAimEnabled then
        local target = GetClosestPlayer(Config.SilentAimFOVRadius)
        if target then
            for _, v in next, args[1] do
                local aim_cf = target[Config.HitPart].CFrame
                local rotated_cf = CFrame.new(camera.CFrame.p, aim_cf.p)
                v.RotationMatrix = (rotated_cf - rotated_cf.p)
                v.OriginCFrame = rotated_cf
            end
        end
    end
    return self, name, unpack(args)
end

local old; old = hookfunction(network.FireServer, function(self, name, ...)
    return old(firesever_new(self, name, {...}))
end)

-- No Recoil Hook
local oldRecoil; oldRecoil = hookfunction(recoil.AddRecoil, function(...)
    if State.NoRecoilEnabled then
        return
    end
    return oldRecoil(...)
end)

local function SafeExecute(func)
    local success, errorMessage = pcall(func)
    if not success then
        warn("Error in SafeExecute: " .. tostring(errorMessage))
    end
end

local function CreateFOVCircle(fovType)
    local circle = Drawing.new('Circle')
    circle.Thickness = 2
    circle.Color = Config.FOVColor
    circle.Filled = false
    circle.Transparency = 1
    circle.Visible = false
    circle.ZIndex = 1
    circle.Radius = fovType == "SilentAim" and Config.SilentAimFOVRadius or Config.AimbotFOVRadius
    circle.Position = UserInputService:GetMouseLocation()
    return circle
end

local function UpdateFOVCircle()
    if not State.SilentAimFOVCircle then
        State.SilentAimFOVCircle = CreateFOVCircle("SilentAim")
    end
    if not State.AimbotFOVCircle then
        State.AimbotFOVCircle = CreateFOVCircle("Aimbot")
    end

    State.SilentAimFOVCircle.Position = UserInputService:GetMouseLocation()
    State.SilentAimFOVCircle.Radius = Config.SilentAimFOVRadius
    State.SilentAimFOVCircle.Visible = State.SilentAimFOVEnabled

    State.AimbotFOVCircle.Position = UserInputService:GetMouseLocation()
    State.AimbotFOVCircle.Radius = Config.AimbotFOVRadius
    State.AimbotFOVCircle.Visible = State.AimbotFOVEnabled
end

local function UpdateFly()
    if not State.FlyEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        if State.FlyConnection then
            State.FlyConnection:Disconnect()
            State.FlyConnection = nil
        end
        if State.OriginalGravity then
            Workspace.Gravity = State.OriginalGravity
            State.OriginalGravity = nil
        end
        return
    end

    if not State.FlyConnection then
        State.OriginalGravity = Workspace.Gravity
        Workspace.Gravity = 0

        local rootPart = LocalPlayer.Character.HumanoidRootPart
        local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.PlatformStand = true
        end

        State.FlyConnection = RunService.RenderStepped:Connect(function(deltaTime)
            local moveDirection = Vector3.new(0, 0, 0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + (camera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - (camera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - (camera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + (camera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                rootPart.Velocity = moveDirection.Unit * Config.FlySpeed
            else
                rootPart.Velocity = Vector3.new(0, 0, 0)
            end
        end)
    end

    if not State.FlyReinitializeConnection then
        State.FlyReinitializeConnection = coroutine.wrap(function()
            while State.FlyEnabled do
                wait(10)
                if State.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    if State.FlyConnection then
                        State.FlyConnection:Disconnect()
                        State.FlyConnection = nil
                    end
                    if State.OriginalGravity then
                        Workspace.Gravity = State.OriginalGravity
                        State.OriginalGravity = nil
                    end
                    UpdateFly()
                end
            end
        end)()
    end
end

local function UpdateNoclip()
    if not State.NoclipEnabled or not LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = true
            end
        end
        return
    end

    for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA('BasePart') then
            part.CanCollide = false
        end
    end
end

local function UpdateInfiniteJump()
    if not State.InfiniteJumpEnabled then
        if State.FlyConnection then
            State.FlyConnection:Disconnect()
            State.FlyConnection = nil
        end
        return
    end

    if not State.FlyConnection then
        State.FlyConnection = RunService.RenderStepped:Connect(function()
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end)
    end
end

local function UpdateAimbot()
    if not State.AimbotEnabled or not State.AimbotLocking or not LocalPlayer.Character then
        return
    end

    local closest, closest_distance = nil, Config.AimbotFOVRadius
    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and (not Config.TeamCheck or player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value) then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Head") then
                local position, on_screen = camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
                if on_screen then
                    local center = UserInputService:GetMouseLocation()
                    local distance = (center - Vector2.new(position.X, position.Y)).Magnitude
                    if distance <= closest_distance then
                        local mag = (character.HumanoidRootPart.CFrame.p - camera.CFrame.p).Magnitude
                        if mag <= State.ESPDistance then
                            closest = character
                            closest_distance = distance
                        end
                    end
                end
            end
        end
    end

    if closest and closest:FindFirstChild('Head') then
        local headPos, onScreen = camera:WorldToViewportPoint(closest.Head.Position)
        if onScreen then
            local mousePos = UserInputService:GetMouseLocation()
            local delta = Vector2.new(headPos.X, headPos.Y) - mousePos
            local smoothingFactor = ((25 - Config.AimbotSmoothing) / 50) ^ 2
            local smoothedDelta = delta * smoothingFactor
            mousemoverel(smoothedDelta.X, smoothedDelta.Y)
        end
    end
end

local function UpdateMovement()
    if not LocalPlayer.Character then
        return
    end

    local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
    local attempts = 0
    while not humanoid and attempts < 50 do
        wait(0.1)
        humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
        attempts = attempts + 1
    end

    if humanoid then
        if State.WalkSpeedEnabled then
            humanoid.WalkSpeed = Config.WalkSpeed
        end
        if State.JumpPowerEnabled then
            humanoid.JumpPower = Config.JumpPower
        end
    else
        warn("Failed to find Humanoid for WalkSpeed/JumpPower update after 5 seconds")
    end
end

local function CreateESP(player)
    local esp = {
        Box = Drawing.new('Square'),
        Name = Drawing.new('Text'),
        Distance = Drawing.new('Text'),
    }

    esp.Box.Thickness = 2
    esp.Box.Color = ESPSettings.BoxColor
    esp.Box.Filled = false
    esp.Box.Visible = false

    esp.Name.Size = 16
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Outline = true
    esp.Name.Center = true
    esp.Name.Visible = false

    esp.Distance.Size = 16
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Outline = true
    esp.Distance.Center = true
    esp.Distance.Visible = false

    return esp
end

local function CreateSkeleton(player)
    local skeleton = {
        HeadToNeck = Drawing.new('Line'),
        NeckToUpperTorso = Drawing.new('Line'),
        UpperTorsoToLowerTorso = Drawing.new('Line'),
        UpperTorsoToLeftUpperArm = Drawing.new('Line'),
        LeftUpperArmToLeftLowerArm = Drawing.new('Line'),
        LeftLowerArmToLeftHand = Drawing.new('Line'),
        UpperTorsoToRightUpperArm = Drawing.new('Line'),
        RightUpperArmToRightLowerArm = Drawing.new('Line'),
        RightLowerArmToRightHand = Drawing.new('Line'),
        LowerTorsoToLeftUpperLeg = Drawing.new('Line'),
        LeftUpperLegToLeftLowerLeg = Drawing.new('Line'),
        LeftLowerLegToLeftFoot = Drawing.new('Line'),
        LowerTorsoToRightUpperLeg = Drawing.new('Line'),
        RightUpperLegToRightLowerLeg = Drawing.new('Line'),
        RightLowerLegToRightFoot = Drawing.new('Line'),
    }

    for _, line in pairs(skeleton) do
        line.Thickness = 2
        line.Color = Config.SkeletonESPColor
        line.Visible = false
    end

    return skeleton
end

local function CreateHealthESP(player)
    local health = {
        BarBackground = Drawing.new('Square'),
        Bar = Drawing.new('Square'),
        Text = Drawing.new('Text'),
    }

    health.BarBackground.Size = Vector2.new(50, 5)
    health.BarBackground.Color = Color3.new(0, 0, 0)
    health.BarBackground.Filled = true
    health.BarBackground.Transparency = 0.5
    health.BarBackground.Visible = false

    health.Bar.Size = Vector2.new(50, 5)
    health.Bar.Color = Color3.new(0, 1, 0)
    health.Bar.Filled = true
    health.Bar.Visible = false

    health.Text.Size = 12
    health.Text.Color = Color3.new(1, 1, 1)
    health.Text.Outline = true
    health.Text.Center = true
    health.Text.Visible = false

    return health
end

local function CreateTracer(player)
    local tracer = Drawing.new('Line')
    tracer.Thickness = 2
    tracer.Color = Color3.new(0, 0.25, 0.75)
    tracer.Visible = false
    return tracer
end

local function ClearESP(player)
    if Caches.ESPCache[player] then
        Caches.ESPCache[player].Box:Remove()
        Caches.ESPCache[player].Name:Remove()
        Caches.ESPCache[player].Distance:Remove()
        Caches.ESPCache[player] = nil
    end
end

local function ClearSkeleton(player)
    if Caches.SkeletonCache[player] then
        for _, line in pairs(Caches.SkeletonCache[player]) do
            line:Remove()
        end
        Caches.SkeletonCache[player] = nil
    end
end

local function ClearHealthESP(player)
    if Caches.HealthCache[player] then
        Caches.HealthCache[player].BarBackground:Remove()
        Caches.HealthCache[player].Bar:Remove()
        Caches.HealthCache[player].Text:Remove()
        Caches.HealthCache[player] = nil
    end
end

local function ClearTracer(player)
    if Caches.TracerCache[player] then
        Caches.TracerCache[player]:Remove()
        Caches.TracerCache[player] = nil
    end
end

local function UpdateESP()
    if not (State.ESPCustomEnabled or State.NameESPEnabled or State.DistanceESPEnabled) then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and (not Config.TeamCheck or player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value) then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if not character or not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
                ClearESP(player)
                continue
            end

            local humanoid = character.Humanoid
            if humanoid.Health <= 0 then
                ClearESP(player)
                continue
            end

            local targetRoot = character.HumanoidRootPart
            local distance = (localRoot.Position - targetRoot.Position).Magnitude
            if distance > State.ESPDistance then
                ClearESP(player)
                continue
            end

            if not Caches.ESPCache[player] then
                Caches.ESPCache[player] = CreateESP(player)
            end

            local esp = Caches.ESPCache[player]
            local rootPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position)
            if onScreen then
                local head = character:FindFirstChild("Head")
                local topPos = head and camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1, 0)) or camera:WorldToViewportPoint(targetRoot.Position + Vector3.new(0, 3, 0))
                local bottomPos = camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
                local height = math.abs(topPos.Y - bottomPos.Y)
                local width = height * 0.5
                local centerPos = Vector2.new(rootPos.X, (topPos.Y + bottomPos.Y) / 2)
                esp.Box.Size = Vector2.new(width, height)
                esp.Box.Position = centerPos - Vector2.new(width / 2, height / 2)
                esp.Box.Visible = ESPSettings.BoxEnabled and State.ESPCustomEnabled
                esp.Name.Text = player.Name
                esp.Name.Position = Vector2.new(rootPos.X, topPos.Y - 20)
                esp.Name.Visible = State.NameESPEnabled
                esp.Distance.Text = tostring(math.floor(distance)) .. " studs"
                esp.Distance.Position = Vector2.new(rootPos.X, bottomPos.Y + 5)
                esp.Distance.Visible = State.DistanceESPEnabled
            else
                esp.Box.Visible = false
                esp.Name.Visible = false
                esp.Distance.Visible = false
            end
        else
            ClearESP(player)
        end
    end
end

local function UpdateSkeletonESP()
    if not State.SkeletonESPEnabled then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and (not Config.TeamCheck or player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value) then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if not character or not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
                ClearSkeleton(player)
                continue
            end

            local humanoid = character.Humanoid
            if humanoid.Health <= 0 then
                ClearSkeleton(player)
                continue
            end

            local targetRoot = character.HumanoidRootPart
            local distance = (localRoot.Position - targetRoot.Position).Magnitude
            if distance > State.ESPDistance then
                ClearSkeleton(player)
                continue
            end

            if not Caches.SkeletonCache[player] then
                Caches.SkeletonCache[player] = CreateSkeleton(player)
            end

            local skeleton = Caches.SkeletonCache[player]
            local parts = {
                Head = character:FindFirstChild("Head"),
                Neck = character:FindFirstChild("Neck") or character:FindFirstChild("Head"),
                UpperTorso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
                LowerTorso = character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso"),
                LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
                LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
                LeftHand = character:FindFirstChild("LeftHand"),
                RightUpperArm = character:FindFirstChild("RightUpperArm"),
                RightLowerArm = character:FindFirstChild("RightLowerArm"),
                RightHand = character:FindFirstChild("RightHand"),
                LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
                LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
                LeftFoot = character:FindFirstChild("LeftFoot"),
                RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
                RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
                RightFoot = character:FindFirstChild("RightFoot"),
            }

            if not (parts.Head and parts.UpperTorso and parts.LowerTorso and parts.LeftUpperArm and parts.LeftLowerArm and parts.LeftHand and parts.RightUpperArm and parts.RightLowerArm and parts.RightHand and parts.LeftUpperLeg and parts.LeftLowerLeg and parts.LeftFoot and parts.RightUpperLeg and parts.RightLowerLeg and parts.RightFoot) then
                ClearSkeleton(player)
                continue
            end

            local headPos, headOnScreen = camera:WorldToViewportPoint(parts.Head.Position)
            local neckPos, neckOnScreen = camera:WorldToViewportPoint(parts.Neck.Position)
            local upperTorsoPos, upperTorsoOnScreen = camera:WorldToViewportPoint(parts.UpperTorso.Position)
            local lowerTorsoPos, lowerTorsoOnScreen = camera:WorldToViewportPoint(parts.LowerTorso.Position)
            local leftUpperArmPos, leftUpperArmOnScreen = camera:WorldToViewportPoint(parts.LeftUpperArm.Position)
            local leftLowerArmPos, leftLowerArmOnScreen = camera:WorldToViewportPoint(parts.LeftLowerArm.Position)
            local leftHandPos, leftHandOnScreen = camera:WorldToViewportPoint(parts.LeftHand.Position)
            local rightUpperArmPos, rightUpperArmOnScreen = camera:WorldToViewportPoint(parts.RightUpperArm.Position)
            local rightLowerArmPos, rightLowerArmOnScreen = camera:WorldToViewportPoint(parts.RightLowerArm.Position)
            local rightHandPos, rightHandOnScreen = camera:WorldToViewportPoint(parts.RightHand.Position)
            local leftUpperLegPos, leftUpperLegOnScreen = camera:WorldToViewportPoint(parts.LeftUpperLeg.Position)
            local leftLowerLegPos, leftLowerLegOnScreen = camera:WorldToViewportPoint(parts.LeftLowerLeg.Position)
            local leftFootPos, leftFootOnScreen = camera:WorldToViewportPoint(parts.LeftFoot.Position)
            local rightUpperLegPos, rightUpperLegOnScreen = camera:WorldToViewportPoint(parts.RightUpperLeg.Position)
            local rightLowerLegPos, rightLowerLegOnScreen = camera:WorldToViewportPoint(parts.RightLowerLeg.Position)
            local rightFootPos, rightFootOnScreen = camera:WorldToViewportPoint(parts.RightFoot.Position)

            if headOnScreen and neckOnScreen then
                skeleton.HeadToNeck.From = Vector2.new(headPos.X, headPos.Y)
                skeleton.HeadToNeck.To = Vector2.new(neckPos.X, neckPos.Y)
                skeleton.HeadToNeck.Visible = true
            else
                skeleton.HeadToNeck.Visible = false
            end

            if neckOnScreen and upperTorsoOnScreen then
                skeleton.NeckToUpperTorso.From = Vector2.new(neckPos.X, neckPos.Y)
                skeleton.NeckToUpperTorso.To = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.NeckToUpperTorso.Visible = true
            else
                skeleton.NeckToUpperTorso.Visible = false
            end

            if upperTorsoOnScreen and lowerTorsoOnScreen then
                skeleton.UpperTorsoToLowerTorso.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToLowerTorso.To = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.UpperTorsoToLowerTorso.Visible = true
            else
                skeleton.UpperTorsoToLowerTorso.Visible = false
            end

            if upperTorsoOnScreen and leftUpperArmOnScreen then
                skeleton.UpperTorsoToLeftUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToLeftUpperArm.To = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
                skeleton.UpperTorsoToLeftUpperArm.Visible = true
            else
                skeleton.UpperTorsoToLeftUpperArm.Visible = false
            end

            if leftUpperArmOnScreen and leftLowerArmOnScreen then
                skeleton.LeftUpperArmToLeftLowerArm.From = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
                skeleton.LeftUpperArmToLeftLowerArm.To = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
                skeleton.LeftUpperArmToLeftLowerArm.Visible = true
            else
                skeleton.LeftUpperArmToLeftLowerArm.Visible = false
            end

            if leftLowerArmOnScreen and leftHandOnScreen then
                skeleton.LeftLowerArmToLeftHand.From = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
                skeleton.LeftLowerArmToLeftHand.To = Vector2.new(leftHandPos.X, leftHandPos.Y)
                skeleton.LeftLowerArmToLeftHand.Visible = true
            else
                skeleton.LeftLowerArmToLeftHand.Visible = false
            end

            if upperTorsoOnScreen and rightUpperArmOnScreen then
                skeleton.UpperTorsoToRightUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToRightUpperArm.To = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
                skeleton.UpperTorsoToRightUpperArm.Visible = true
            else
                skeleton.UpperTorsoToRightUpperArm.Visible = false
            end

            if rightUpperArmOnScreen and rightLowerArmOnScreen then
                skeleton.RightUpperArmToRightLowerArm.From = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
                skeleton.RightUpperArmToRightLowerArm.To = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
                skeleton.RightUpperArmToRightLowerArm.Visible = true
            else
                skeleton.RightUpperArmToRightLowerArm.Visible = false
            end

            if rightLowerArmOnScreen and rightHandOnScreen then
                skeleton.RightLowerArmToRightHand.From = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
                skeleton.RightLowerArmToRightHand.To = Vector2.new(rightHandPos.X, rightHandPos.Y)
                skeleton.RightLowerArmToRightHand.Visible = true
            else
                skeleton.RightLowerArmToRightHand.Visible = false
            end

            if lowerTorsoOnScreen and leftUpperLegOnScreen then
                skeleton.LowerTorsoToLeftUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.LowerTorsoToLeftUpperLeg.To = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
                skeleton.LowerTorsoToLeftUpperLeg.Visible = true
            else
                skeleton.LowerTorsoToLeftUpperLeg.Visible = false
            end

            if leftUpperLegOnScreen and leftLowerLegOnScreen then
                skeleton.LeftUpperLegToLeftLowerLeg.From = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
                skeleton.LeftUpperLegToLeftLowerLeg.To = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
                skeleton.LeftUpperLegToLeftLowerLeg.Visible = true
            else
                skeleton.LeftUpperLegToLeftLowerLeg.Visible = false
            end

            if leftLowerLegOnScreen and leftFootOnScreen then
                skeleton.LeftLowerLegToLeftFoot.From = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
                skeleton.LeftLowerLegToLeftFoot.To = Vector2.new(leftFootPos.X, leftFootPos.Y)
                skeleton.LeftLowerLegToLeftFoot.Visible = true
            else
                skeleton.LeftLowerLegToLeftFoot.Visible = false
            end

            if lowerTorsoOnScreen and rightUpperLegOnScreen then
                skeleton.LowerTorsoToRightUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.LowerTorsoToRightUpperLeg.To = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
                skeleton.LowerTorsoToRightUpperLeg.Visible = true
            else
                skeleton.LowerTorsoToRightUpperLeg.Visible = false
            end

            if rightUpperLegOnScreen and rightLowerLegOnScreen then
                skeleton.RightUpperLegToRightLowerLeg.From = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
                skeleton.RightUpperLegToRightLowerLeg.To = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
                skeleton.RightUpperLegToRightLowerLeg.Visible = true
            else
                skeleton.RightUpperLegToRightLowerLeg.Visible = false
            end

            if rightLowerLegOnScreen and rightFootOnScreen then
                skeleton.RightLowerLegToRightFoot.From = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
                skeleton.RightLowerLegToRightFoot.To = Vector2.new(rightFootPos.X, rightFootPos.Y)
                skeleton.RightLowerLegToRightFoot.Visible = true
            else
                skeleton.RightLowerLegToRightFoot.Visible = false
            end
        else
            ClearSkeleton(player)
        end
    end
end

local function UpdateHealthESP()
    if not State.HealthESPEnabled then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and (not Config.TeamCheck or player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value) then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if not character or not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
                ClearHealthESP(player)
                continue
            end

            local humanoid = character.Humanoid
            if humanoid.Health <= 0 then
                ClearHealthESP(player)
                continue
            end

            local targetRoot = character.HumanoidRootPart
            local distance = (localRoot.Position - targetRoot.Position).Magnitude
            if distance > State.ESPDistance then
                ClearHealthESP(player)
                continue
            end

            if not Caches.HealthCache[player] then
                Caches.HealthCache[player] = CreateHealthESP(player)
            end

            local health = Caches.HealthCache[player]
            local headPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
            if onScreen then
                local healthPercentage = humanoid.Health / humanoid.MaxHealth
                health.BarBackground.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
                health.BarBackground.Visible = true
                health.Bar.Size = Vector2.new(50 * healthPercentage, 5)
                health.Bar.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
                health.Bar.Color = Color3.new(1 - healthPercentage, healthPercentage, 0)
                health.Bar.Visible = true
                health.Text.Text = tostring(math.floor(healthPercentage * 100)) .. "%"
                health.Text.Position = Vector2.new(headPos.X, headPos.Y - 45)
                health.Text.Visible = true
            else
                health.BarBackground.Visible = false
                health.Bar.Visible = false
                health.Text.Visible = false
            end
        else
            ClearHealthESP(player)
        end
    end
end

local function UpdateTracerESP()
    if not State.TracerESPEnabled then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    local screenSize = camera.ViewportSize
    local tracerFrom
    if Config.TracerOrigin == 'Bottom Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, screenSize.Y)
    elseif Config.TracerOrigin == 'Cursor' then
        tracerFrom = UserInputService:GetMouseLocation()
    elseif Config.TracerOrigin == 'Top Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, 0)
    end

    for _, player in next, players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer and (not Config.TeamCheck or player.SelectedTeam.Value ~= LocalPlayer.SelectedTeam.Value) then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if not character or not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
                ClearTracer(player)
                continue
            end

            local humanoid = character.Humanoid
            if humanoid.Health <= 0 then
                ClearTracer(player)
                continue
            end

            local targetHead = character:FindFirstChild("Head") or character.HumanoidRootPart
            local distance = (localRoot.Position - targetHead.Position).Magnitude
            if distance > State.ESPDistance then
                ClearTracer(player)
                continue
            end

            if not Caches.TracerCache[player] then
                Caches.TracerCache[player] = CreateTracer(player)
            end

            local tracer = Caches.TracerCache[player]
            local headPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
            tracer.From = tracerFrom
            tracer.To = Vector2.new(headPos.X, headPos.Y)
            tracer.Visible = onScreen
        else
            ClearTracer(player)
        end
    end
end

players.PlayerRemoving:Connect(function(player)
    SafeExecute(function()
        ClearESP(player)
        ClearSkeleton(player)
        ClearHealthESP(player)
        ClearTracer(player)
        if State.FollowTarget == player then
            if State.FollowConnection then
                State.FollowConnection:Disconnect()
                State.FollowConnection = nil
            end
            State.FollowTarget = nil
        end
        if State.SpectateTarget == player then
            if State.SpectateConnection then
                State.SpectateConnection:Disconnect()
                State.SpectateConnection = nil
            end
            State.SpectateTarget = nil
            State.SpectateEnabled = false
            camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
        end
    end)
end)

players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        character.AncestryChanged:Connect(function()
            if not character:IsDescendantOf(Workspace) then
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end)
            end
        end)
        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.Died:Connect(function()
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end)
            end)
        end
    end)
end)

LocalPlayer.CharacterAdded:Connect(function(character)
    SafeExecute(function()
        local humanoid = character:WaitForChild('Humanoid', 5)
        if humanoid then
            if State.FlyEnabled then
                if State.FlyConnection then
                    State.FlyConnection:Disconnect()
                    State.FlyConnection = nil
                end
                if State.OriginalGravity then
                    Workspace.Gravity = State.OriginalGravity
                    State.OriginalGravity = nil
                end
                UpdateFly()
            end
            if State.NoclipEnabled then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA('BasePart') then
                        part.CanCollide = true
                    end
                end
                UpdateNoclip()
            end
            if State.InfiniteJumpEnabled then
                if State.FlyConnection then
                    State.FlyConnection:Disconnect()
                    State.FlyConnection = nil
                end
                UpdateInfiniteJump()
            end
            if State.WalkSpeedEnabled or State.JumpPowerEnabled then
                UpdateMovement()
            end
            if not State.SpectateEnabled then
                camera.CameraSubject = humanoid
            end
        end
    end)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        State.AimbotLocking = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        State.AimbotLocking = false
    end
end)

local function GetPlayerNames()
    local names = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(names, player.Name)
        end
    end
    return names
end



local Window = Library:CreateWindow({
    Title = 'Rush Point X | By zixy.py2',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
})

local Tabs = {
    Legit = Window:AddTab('Legit'),
    Rage = Window:AddTab('Rage'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    Exploits = Window:AddTab('Exploits'),
    Settings = Window:AddTab('UI Settings'),
}

local LegitGroup = Tabs.Legit:AddLeftGroupbox('Legit Controls')

LegitGroup:AddToggle('AimbotToggle', {
    Text = 'Enable Aimbot',
    Default = false,
    Callback = function(Value)
        State.AimbotEnabled = Value
        if not State.AimbotEnabled then
            State.AimbotLocking = false
        end
    end,
})

LegitGroup:AddToggle('AimbotFOVToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(Value)
        State.AimbotFOVEnabled = Value
        if not State.AimbotFOVEnabled and State.AimbotFOVCircle then
            State.AimbotFOVCircle.Visible = false
        end
    end,
})

LegitGroup:AddSlider('AimbotFOVSizeSlider', {
    Text = 'FOV Size',
    Default = Config.AimbotFOVRadius,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Callback = function(Value)
        Config.AimbotFOVRadius = Value
    end,
})

LegitGroup:AddSlider('AimbotSmoothingSlider', {
    Text = 'Smoothing',
    Default = Config.AimbotSmoothing,
    Min = 0,
    Max = 25,
    Rounding = 0,
    Callback = function(Value)
        Config.AimbotSmoothing = Value
    end,
})

local RageGroup = Tabs.Rage:AddLeftGroupbox('Rage Controls')

RageGroup:AddToggle('SilentAimToggle', {
    Text = 'Enable Silent Aim',
    Default = false,
    Callback = function(Value)
        State.SilentAimEnabled = Value
    end,
})

RageGroup:AddToggle('SilentAimFOVToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(Value)
        State.SilentAimFOVEnabled = Value
        if not State.SilentAimFOVEnabled and State.SilentAimFOVCircle then
            State.SilentAimFOVCircle.Visible = false
        end
    end,
})

RageGroup:AddSlider('SilentAimFOVSizeSlider', {
    Text = 'FOV Size',
    Default = Config.SilentAimFOVRadius,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        Config.SilentAimFOVRadius = Value
    end,
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('Visual Controls')

VisualsGroup:AddToggle('ESPCustomToggle', {
    Text = 'Box ESP',
    Default = false,
    Callback = function(Value)
        State.ESPCustomEnabled = Value
        if not State.ESPCustomEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Box.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('NameESPToggle', {
    Text = 'Name ESP',
    Default = false,
    Callback = function(Value)
        State.NameESPEnabled = Value
        if not State.NameESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Name.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('DistanceESPToggle', {
    Text = 'Distance ESP',
    Default = false,
    Callback = function(Value)
        State.DistanceESPEnabled = Value
        if not State.DistanceESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Distance.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('SkeletonESPToggle', {
    Text = 'Skeleton ESP',
    Default = false,
    Callback = function(Value)
        State.SkeletonESPEnabled = Value
        if not State.SkeletonESPEnabled then
            for player, _ in pairs(Caches.SkeletonCache) do
                ClearSkeleton(player)
            end
        end
    end,
})

VisualsGroup:AddToggle('HealthESPToggle', {
    Text = 'Health ESP',
    Default = false,
    Callback = function(Value)
        State.HealthESPEnabled = Value
        if not State.HealthESPEnabled then
            for player, _ in pairs(Caches.HealthCache) do
                ClearHealthESP(player)
            end
        end
    end,
})

VisualsGroup:AddToggle('TracerESPToggle', {
    Text = 'Tracer ESP',
    Default = false,
    Callback = function(Value)
        State.TracerESPEnabled = Value
        if not State.TracerESPEnabled then
            for player, _ in pairs(Caches.TracerCache) do
                ClearTracer(player)
            end
        end
    end,
})

VisualsGroup:AddDropdown('TracerOriginDropdown', {
    Text = 'Tracer Origin',
    Default = Config.TracerOrigin,
    Values = {'Bottom Screen', 'Cursor', 'Top Screen'},
    Callback = function(Value)
        Config.TracerOrigin = Value
    end,
})

VisualsGroup:AddToggle('ESPTeamCheckToggle', {
    Text = 'Team Check',
    Default = Config.TeamCheck,
    Callback = function(Value)
        Config.TeamCheck = Value
    end,
})

local PlayerGroup = Tabs.Player:AddLeftGroupbox('Player Controls')

PlayerGroup:AddToggle('NoclipToggle', {
    Text = 'Enable Noclip',
    Default = false,
    Callback = function(Value)
        State.NoclipEnabled = Value
        UpdateNoclip()
    end,
})


local ExploitsGroup = Tabs.Exploits:AddLeftGroupbox('Exploit Controls')


local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end,
    Tooltip = 'Unloads the script',
})

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind',
})

Library.ToggleKeybind = Options.MenuKeybind

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Rush Point X | Made by zixy.py2')

Library:OnUnload(function()
    if State.SilentAimFOVCircle then
        State.SilentAimFOVCircle:Remove()
    end
    if State.AimbotFOVCircle then
        State.AimbotFOVCircle:Remove()
    end
    if State.FlyReinitializeConnection then
        State.FlyReinitializeConnection = nil
    end
    if State.FollowConnection then
        State.FollowConnection:Disconnect()
        State.FollowConnection = nil
    end
    if State.SpectateConnection then
        State.SpectateConnection:Disconnect()
        State.SpectateConnection = nil
    end
    network.FireServer = old
    recoil.AddRecoil = oldRecoil
    State.FlyEnabled = false
    State.NoclipEnabled = false
    State.InfiniteJumpEnabled = false
    State.ESPCustomEnabled = false
    State.NameESPEnabled = false
    State.DistanceESPEnabled = false
    State.SkeletonESPEnabled = false
    State.HealthESPEnabled = false
    State.TracerESPEnabled = false
    State.NoRecoilEnabled = false
    State.WalkSpeedEnabled = false
    State.JumpPowerEnabled = false
    State.SpectateEnabled = false
    UpdateFly()
    UpdateNoclip()
    UpdateInfiniteJump()
    UpdateESP()
    UpdateSkeletonESP()
    UpdateHealthESP()
    UpdateTracerESP()
    camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
    Library.Unloaded = true
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Library:Notify(
    'Cheat Loaded',
    'Rush Point X is ready! Press RightShift to toggle GUI.',
    5
)

coroutine.wrap(function()
    local attempts = 0
    while not LocalPlayer.Character and attempts < 50 do
        wait(0.1)
        attempts = attempts + 1
    end
    if LocalPlayer.Character then
        SafeExecute(UpdateMovement)
    end
end)()

RunService.RenderStepped:Connect(function()
    SafeExecute(UpdateFOVCircle)
    SafeExecute(UpdateNoclip)
    SafeExecute(UpdateESP)
    SafeExecute(UpdateSkeletonESP)
    SafeExecute(UpdateHealthESP)
    SafeExecute(UpdateTracerESP)
    SafeExecute(UpdateAimbot)
    SafeExecute(UpdateMovement)
end)
