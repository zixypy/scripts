local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local UserInputService = game:GetService('UserInputService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local HttpService = game:GetService('HttpService')

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
ThemeManager:SetFolder('RushPointX')
SaveManager:SetFolder('RushPointX')
ThemeManager:SaveDefault('Tokyo Night')

local camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local network = require(ReplicatedStorage.Modules.Shared.Network)
local recoil = require(ReplicatedStorage.Modules.Client.Helpers.RecoilHandler)
local bac_characters_senv = getsenv(game.ReplicatedStorage.BAC.Characters)

local Config = {
    SilentAimHitPart = 'Head',
    AimbotHitPart = 'Head',
    TeamCheck = true,
    FOVColor = Color3.fromRGB(255, 255, 255),
    SilentAimFOVRadius = 100,
    AimbotFOVRadius = 100,
    FlySpeed = 50,
    AimbotSmoothing = 0,
    SkeletonESPColor = Color3.new(0, 0.25, 0.75),
    TracerOrigin = 'Bottom Screen',
    WalkSpeed = 16,
    JumpPower = 50,
    SilentAimHitchance = 100,
    CustomGunColor = Color3.new(1, 0, 0),
    CustomGunTransparency = 0,
}

local ESPSettings = {
    BoxEnabled = true,
    BoxColor = Color3.new(0, 0.25, 0.75),
}

local State = {
    ESPDistance = 750,
    SilentAimEnabled = false,
    SilentAimFOVEnabled = false,
    SilentAim360FOV = false,
    ESPCustomEnabled = false,
    NameESPEnabled = false,
    DistanceESPEnabled = false,
    SkeletonESPEnabled = false,
    HealthESPEnabled = false,
    TracerESPEnabled = false,
    FlyEnabled = false,
    NoclipEnabled = false,
    InfiniteJumpEnabled = false,
    AimbotEnabled = false,
    AimbotFOVEnabled = false,
    Aimbot360FOV = false,
    AimbotLocking = false,
    NoRecoilEnabled = false,
    NoSpreadEnabled = false,
    RapidFireEnabled = false,
    WalkSpeedEnabled = false,
    JumpPowerEnabled = false,
    SilentAimFOVCircle = nil,
    AimbotFOVCircle = nil,
    OriginalGravity = nil,
    FlyConnection = nil,
    FlyReinitializeConnection = nil,
    RagebotEnabled = false,
    IsRagebotShooting = false,
    VisibleCheckEnabled = false,
    RainbowGunEnabled = false,
    CustomGunColorEnabled = false,
    WeaponConnection = nil,
    RainbowHue = 0, -- Added for synchronized rainbow effect
    RainbowTask = nil, -- Tracks rainbow effect task
    RapidFireTask = nil, -- Tracks rainbow effect task
    NoSpreadTask = nil, -- Tracks rainbow effect task

}

local Caches = {
    ESPCache = {},
    SkeletonCache = {},
    HealthCache = {},
    TracerCache = {},
}

local SessionID = HttpService:GenerateGUID(false)

local function ShouldShowPlayer(player, character, distance)
    if player == LocalPlayer or not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") or character.Humanoid.Health <= 0 then
        return false
    end
    if distance > State.ESPDistance then
        return false
    end
    if not Config.TeamCheck then
        return true
    end
    local localTeam = LocalPlayer:FindFirstChild("SelectedTeam") and LocalPlayer.SelectedTeam.Value or nil
    local playerTeam = player:FindFirstChild("SelectedTeam") and player.SelectedTeam.Value or nil
    if not localTeam or not playerTeam then
        warn("Team data missing for " .. player.Name .. ": localTeam=" .. tostring(localTeam) .. ", playerTeam=" .. tostring(playerTeam))
        return false
    end
    return localTeam ~= playerTeam
end

local function IsPlayerVisible(targetCharacter, hitPart)
    if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        return false
    end
    local origin = camera.CFrame.Position
    local targetPos = targetCharacter[hitPart].Position
    local ray = Ray.new(origin, (targetPos - origin).Unit * 500)
    local ignoreList = {LocalPlayer.Character}
    local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit and hit:IsDescendantOf(targetCharacter)
end

local function GetClosestPlayer(fovRadius, isAimbot)
    local dist, target = math.huge, nil
    local hitPart = isAimbot and Config.AimbotHitPart or Config.SilentAimHitPart
    local use360FOV = isAimbot and State.Aimbot360FOV or State.SilentAim360FOV

    for _, player in next, Players:GetChildren() do
        if player:IsA('Player') and player ~= LocalPlayer then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild(hitPart) and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                local position, on_screen = camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
                if on_screen then
                    local center = UserInputService:GetMouseLocation()
                    local distance = (center - Vector2.new(position.X, position.Y)).Magnitude
                    if use360FOV or distance <= fovRadius then
                        local mag = (character.HumanoidRootPart.CFrame.p - camera.CFrame.p).Magnitude
                        if mag < dist and mag <= State.ESPDistance then
                            if ShouldShowPlayer(player, character, mag) then
                                if State.VisibleCheckEnabled and not IsPlayerVisible(character, hitPart) then
                                    continue
                                end
                                dist = mag
                                target = character
                            end
                        end
                    end
                end
            end
        end
    end

    return target
end

local firesever_new = function(self, name, args)
    if name == 'FireBullet' and State.SilentAimEnabled then
        if Config.SilentAimHitchance < 100 and math.random(1, 100) > Config.SilentAimHitchance then
            return self, name, unpack(args)
        end
        local target = GetClosestPlayer(Config.SilentAimFOVRadius, false)
        if target and target:FindFirstChild(Config.SilentAimHitPart) then
            for _, v in next, args[1] do
                local aim_cf = target[Config.SilentAimHitPart].CFrame
                local rotated_cf = CFrame.new(camera.CFrame.p, aim_cf.p)
                v.RotationMatrix = (rotated_cf - rotated_cf.p)
                v.OriginCFrame = rotated_cf
            end
        end
    end
    return self, name, unpack(args)
end

local old; old = hookfunction(network.FireServer, function(self, name, ...)
    return old(firesever_new(self, name, {...}))
end)

local oldRecoil; oldRecoil = hookfunction(recoil.AddRecoil, function(...)
    if State.NoRecoilEnabled then
        return
    end
    return oldRecoil(...)
end)

local function SafeExecute(func, description)
    local success, errorMessage = pcall(func)
    if not success then
        warn("Error in " .. (description or "SafeExecute") .. ": " .. tostring(errorMessage))
    end
end

local function CreateFOVCircle(fovType)
    local circle = Drawing.new('Circle')
    circle.Thickness = 2
    circle.Color = Config.FOVColor
    circle.Filled = false
    circle.Transparency = 1
    circle.Visible = false
    circle.ZIndex = 1
    circle.Radius = fovType == "SilentAim" and Config.SilentAimFOVRadius or Config.AimbotFOVRadius
    circle.Position = UserInputService:GetMouseLocation()
    return circle
end

local function UpdateFOVCircle()
    if not State.SilentAimFOVCircle then
        State.SilentAimFOVCircle = CreateFOVCircle("SilentAim")
    end
    if not State.AimbotFOVCircle then
        State.AimbotFOVCircle = CreateFOVCircle("Aimbot")
    end

    local mousePos = UserInputService:GetMouseLocation()
    State.SilentAimFOVCircle.Position = mousePos
    State.SilentAimFOVCircle.Radius = Config.SilentAimFOVRadius
    State.SilentAimFOVCircle.Visible = State.SilentAimFOVEnabled and not State.SilentAim360FOV

    State.AimbotFOVCircle.Position = mousePos
    State.AimbotFOVCircle.Radius = Config.AimbotFOVRadius
    State.AimbotFOVCircle.Visible = State.AimbotFOVEnabled and not State.Aimbot360FOV
end

local function UpdateRagebot()
    if not State.RagebotEnabled or not LocalPlayer.Character then
        if State.IsRagebotShooting then
            State.IsRagebotShooting = false
        end
        return
    end

    local target = GetClosestPlayer(Config.SilentAimFOVRadius, false)
    if target and target:FindFirstChild(Config.SilentAimHitPart) then
        local headPos, onScreen = camera:WorldToViewportPoint(target[Config.SilentAimHitPart].Position)
        if onScreen and IsPlayerVisible(target, Config.SilentAimHitPart) then
            State.SilentAimEnabled = true
            if not State.IsRagebotShooting then
                State.IsRagebotShooting = true
                coroutine.wrap(function()
                    while State.RagebotEnabled and State.IsRagebotShooting do
                        mouse1press()
                        wait(0.0005)
                        mouse1release()
                        wait(0.001 - 0.0005)
                    end
                end)()
            end
        else
            if State.IsRagebotShooting then
                State.IsRagebotShooting = false
            end
        end
    else
        if State.IsRagebotShooting then
            State.IsRagebotShooting = false
        end
    end
end

local function UpdateFly()
    if not State.FlyEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        if State.FlyConnection then
            State.FlyConnection:Disconnect()
            State.FlyConnection = nil
        end
        if State.OriginalGravity then
            Workspace.Gravity = State.OriginalGravity
            State.OriginalGravity = nil
        end
        return
    end

    if not State.FlyConnection then
        State.OriginalGravity = Workspace.Gravity
        Workspace.Gravity = 0

        local rootPart = LocalPlayer.Character.HumanoidRootPart
        local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.PlatformStand = true
        end

        State.FlyConnection = RunService.RenderStepped:Connect(function(deltaTime)
            local moveDirection = Vector3.new(0, 0, 0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + (camera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - (camera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - (camera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + (camera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                rootPart.Velocity = moveDirection.Unit * Config.FlySpeed
            else
                rootPart.Velocity = Vector3.new(0, 0, 0)
            end
        end)
    end

    if not State.FlyReinitializeConnection then
        State.FlyReinitializeConnection = coroutine.wrap(function()
            while State.FlyEnabled do
                wait(10)
                if State.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
                    if State.FlyConnection then
                        State.FlyConnection:Disconnect()
                        State.FlyConnection = nil
                    end
                    if State.OriginalGravity then
                        Workspace.Gravity = State.OriginalGravity
                        State.OriginalGravity = nil
                    end
                    UpdateFly()
                end
            end
        end)()
    end
end

local function UpdateNoclip()
    if not State.NoclipEnabled or not LocalPlayer.Character then
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = true
            end
        end
        return
    end

    for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA('BasePart') then
            part.CanCollide = false
        end
    end
end

local function UpdateInfiniteJump()
    if not State.InfiniteJumpEnabled then
        if State.FlyConnection then
            State.FlyConnection:Disconnect()
            State.FlyConnection = nil
        end
        return
    end

    if not State.FlyConnection then
        State.FlyConnection = RunService.RenderStepped:Connect(function()
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end)
    end
end

local function UpdateAimbot()
    if not State.AimbotEnabled or not State.AimbotLocking or not LocalPlayer.Character then
        return
    end

    local closest = GetClosestPlayer(Config.AimbotFOVRadius, true)
    if closest and closest:FindFirstChild(Config.AimbotHitPart) then
        local headPos, onScreen = camera:WorldToViewportPoint(closest[Config.AimbotHitPart].Position)
        if onScreen then
            local mousePos = UserInputService:GetMouseLocation()
            local delta = Vector2.new(headPos.X, headPos.Y) - mousePos
            local smoothingFactor = ((25 - Config.AimbotSmoothing) / 50) ^ 2
            local smoothedDelta = delta * smoothingFactor
            mousemoverel(smoothedDelta.X, smoothedDelta.Y)
        end
    end
end

local function UpdateMovement()
    if not LocalPlayer.Character then
        return
    end

    local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
    local attempts = 0
    while not humanoid and attempts < 50 do
        wait(0.1)
        humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
        attempts = attempts + 1
    end

    if humanoid then
        if State.WalkSpeedEnabled then
            humanoid.WalkSpeed = Config.WalkSpeed
        end
        if State.JumpPowerEnabled then
            humanoid.JumpPower = Config.JumpPower
        end
    else
        warn("Failed to find Humanoid for WalkSpeed/JumpPower update after 5 seconds")
    end
end

local function ResetGunAppearance()
    local weapon = camera:FindFirstChild('Weapon') or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Weapon'))
    if not weapon then
        return
    end
    for _, desc in weapon:GetDescendants() do
        if desc:IsA('BasePart') then
            desc.Material = Enum.Material.Plastic
            desc.Transparency = 0
        end
    end
end

local function UpdateGunAppearance()
    local weapon = camera:FindFirstChild('Weapon') or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Weapon'))
    if not weapon then
        return
    end
    -- Only modify appearance if RainbowGun or CustomGunColor is enabled
    if State.RainbowGunEnabled or State.CustomGunColorEnabled then
        for _, desc in weapon:GetDescendants() do
            if desc.Name == 'SurfaceAppearance' then
                desc:Destroy()
            end
            if desc:IsA('BasePart') then
                desc.Material = Enum.Material.ForceField
                if State.RainbowGunEnabled then
                    desc.Color = Color3.fromHSV(State.RainbowHue or 0, 1, 1)
                elseif State.CustomGunColorEnabled then
                    desc.Color = Config.CustomGunColor
                    desc.Transparency = Config.CustomGunTransparency
                end
            end
        end
    end
end
local function StartRainbowEffect()
    if State.RainbowTask then
        return
    end
    State.RainbowTask = task.spawn(function()
        while State.RainbowGunEnabled do
            State.RainbowHue = (State.RainbowHue or 0) + 0.01
            if State.RainbowHue > 1 then
                State.RainbowHue = 0
            end
            SafeExecute(UpdateGunAppearance, "UpdateGunAppearance for Rainbow")
            task.wait(0.03)
        end
        State.RainbowTask = nil
    end)
end
camera.ChildAdded:Connect(function(child)
    if child.Name == 'Weapon' then
        SafeExecute(UpdateGunAppearance, "UpdateGunAppearance on Camera ChildAdded")
    end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
    SafeExecute(function()
        local humanoid = character:WaitForChild('Humanoid', 5)
        if humanoid then
            if State.FlyEnabled then
                if State.FlyConnection then
                    State.FlyConnection:Disconnect()
                    State.FlyConnection = nil
                end
                if State.OriginalGravity then
                    Workspace.Gravity = State.OriginalGravity
                    State.OriginalGravity = nil
                end
                UpdateFly()
            end
            if State.NoclipEnabled then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA('BasePart') then
                        part.CanCollide = true
                    end
                end
                UpdateNoclip()
            end
            if State.InfiniteJumpEnabled then
                if State.FlyConnection then
                    State.FlyConnection:Disconnect()
                    State.FlyConnection = nil
                end
                UpdateInfiniteJump()
            end
            if State.WalkSpeedEnabled or State.JumpPowerEnabled then
                UpdateMovement()
            end
            -- Monitor weapon changes in character
            State.WeaponConnection = character.ChildAdded:Connect(function(child)
                if child.Name == 'Weapon' then
                    SafeExecute(UpdateGunAppearance, "UpdateGunAppearance on Character ChildAdded")
                end
            end)
        end
    end, "CharacterAdded")
end)

local function CreateESP(player)
    local esp = {
        Box = Drawing.new('Square'),
        Name = Drawing.new('Text'),
        Distance = Drawing.new('Text'),
    }

    esp.Box.Thickness = 2
    esp.Box.Color = ESPSettings.BoxColor
    esp.Box.Filled = false
    esp.Box.Visible = false

    esp.Name.Size = 16
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Outline = true
    esp.Name.Center = true
    esp.Name.Visible = false

    esp.Distance.Size = 16
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Outline = true
    esp.Distance.Center = true
    esp.Distance.Visible = false

    return esp
end

local function CreateSkeleton(player)
    local skeleton = {
        HeadToNeck = Drawing.new('Line'),
        NeckToUpperTorso = Drawing.new('Line'),
        UpperTorsoToLowerTorso = Drawing.new('Line'),
        UpperTorsoToLeftUpperArm = Drawing.new('Line'),
        LeftUpperArmToLeftLowerArm = Drawing.new('Line'),
        LeftLowerArmToLeftHand = Drawing.new('Line'),
        UpperTorsoToRightUpperArm = Drawing.new('Line'),
        RightUpperArmToRightLowerArm = Drawing.new('Line'),
        RightLowerArmToRightHand = Drawing.new('Line'),
        LowerTorsoToLeftUpperLeg = Drawing.new('Line'),
        LeftUpperLegToLeftLowerLeg = Drawing.new('Line'),
        LeftLowerLegToLeftFoot = Drawing.new('Line'),
        LowerTorsoToRightUpperLeg = Drawing.new('Line'),
        RightUpperLegToRightLowerLeg = Drawing.new('Line'),
        RightLowerLegToRightFoot = Drawing.new('Line'),
    }

    for _, line in pairs(skeleton) do
        line.Thickness = 2
        line.Color = Config.SkeletonESPColor
        line.Visible = false
    end

    return skeleton
end

local function CreateHealthESP(player)
    local health = {
        BarBackground = Drawing.new('Square'),
        Bar = Drawing.new('Square'),
        Text = Drawing.new('Text'),
    }

    health.BarBackground.Size = Vector2.new(50, 5)
    health.BarBackground.Color = Color3.new(0, 0, 0)
    health.BarBackground.Filled = true
    health.BarBackground.Transparency = 0.5
    health.BarBackground.Visible = false

    health.Bar.Size = Vector2.new(50, 5)
    health.Bar.Color = Color3.new(0, 1, 0)
    health.Bar.Filled = true
    health.Bar.Visible = false

    health.Text.Size = 12
    health.Text.Color = Color3.new(1, 1, 1)
    health.Text.Outline = true
    health.Text.Center = true
    health.Text.Visible = false

    return health
end

local function CreateTracer(player)
    local tracer = Drawing.new('Line')
    tracer.Thickness = 2
    tracer.Color = Color3.new(0, 0.25, 0.75)
    tracer.Visible = false
    return tracer
end

local function ClearESP(player)
    if Caches.ESPCache[player] then
        Caches.ESPCache[player].Box:Remove()
        Caches.ESPCache[player].Name:Remove()
        Caches.ESPCache[player].Distance:Remove()
        Caches.ESPCache[player] = nil
    end
end

local function ClearSkeleton(player)
    if Caches.SkeletonCache[player] then
        for _, line in pairs(Caches.SkeletonCache[player]) do
            line:Remove()
        end
        Caches.SkeletonCache[player] = nil
    end
end

local function ClearHealthESP(player)
    if Caches.HealthCache[player] then
        Caches.HealthCache[player].BarBackground:Remove()
        Caches.HhealthCache[player].Bar:Remove()
        Caches.HealthCache[player].Text:Remove()
        Caches.HealthCache[player] = nil
    end
end

local function ClearTracer(player)
    if Caches.TracerCache[player] then
        Caches.TracerCache[player]:Remove()
        Caches.TracerCache[player] = nil
    end
end

local function UpdateESP()
    if not (State.ESPCustomEnabled or State.NameESPEnabled or State.DistanceESPEnabled) then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, Players:GetChildren() do
        if player:IsA('Player') then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            local distance = character and character:FindFirstChild('HumanoidRootPart') and (localRoot.Position - character.HumanoidRootPart.Position).Magnitude or math.huge
            if not ShouldShowPlayer(player, character, distance) then
                ClearESP(player)
                continue
            end

            if not Caches.ESPCache[player] then
                Caches.ESPCache[player] = CreateESP(player)
            end

            local esp = Caches.ESPCache[player]
            local rootPos, onScreen = camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
            if onScreen then
                local head = character:FindFirstChild("Head")
                local topPos = head and camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1, 0)) or camera:WorldToViewportPoint(character.HumanoidRootPart.Position + Vector3.new(0, 3, 0))
                local bottomPos = camera:WorldToViewportPoint(character.HumanoidRootPart.Position - Vector3.new(0, 3, 0))
                local height = math.abs(topPos.Y - bottomPos.Y)
                local width = height * 0.5
                local centerPos = Vector2.new(rootPos.X, (topPos.Y + bottomPos.Y) / 2)
                esp.Box.Size = Vector2.new(width, height)
                esp.Box.Position = centerPos - Vector2.new(width / 2, height / 2)
                esp.Box.Visible = ESPSettings.BoxEnabled and State.ESPCustomEnabled
                esp.Name.Text = player.Name
                esp.Name.Position = Vector2.new(rootPos.X, topPos.Y - 20)
                esp.Name.Visible = State.NameESPEnabled
                esp.Distance.Text = tostring(math.floor(distance)) .. " studs"
                esp.Distance.Position = Vector2.new(rootPos.X, bottomPos.Y + 5)
                esp.Distance.Visible = State.DistanceESPEnabled
            else
                esp.Box.Visible = false
                esp.Name.Visible = false
                esp.Distance.Visible = false
            end
        else
            ClearESP(player)
        end
    end
end

local function UpdateSkeletonESP()
    if not State.SkeletonESPEnabled then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, Players:GetChildren() do
        if player:IsA('Player') then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            local distance = character and character:FindFirstChild('HumanoidRootPart') and (localRoot.Position - character.HumanoidRootPart.Position).Magnitude or math.huge
            if not ShouldShowPlayer(player, character, distance) then
                ClearSkeleton(player)
                continue
            end

            if not Caches.SkeletonCache[player] then
                Caches.SkeletonCache[player] = CreateSkeleton(player)
            end

            local skeleton = Caches.SkeletonCache[player]
            local parts = {
                Head = character:FindFirstChild("Head"),
                Neck = character:FindFirstChild("Neck") or character:FindFirstChild("Head"),
                UpperTorso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
                LowerTorso = character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso"),
                LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
                LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
                LeftHand = character:FindFirstChild("LeftHand"),
                RightUpperArm = character:FindFirstChild("RightUpperArm"),
                RightLowerArm = character:FindFirstChild("RightLowerArm"),
                RightHand = character:FindFirstChild("RightHand"),
                LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
                LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
                LeftFoot = character:FindFirstChild("LeftFoot"),
                RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
                RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
                RightFoot = character:FindFirstChild("RightFoot"),
            }

            if not (parts.Head and parts.UpperTorso and parts.LowerTorso and parts.LeftUpperArm and parts.LeftLowerArm and parts.LeftHand and parts.RightUpperArm and parts.RightLowerArm and parts.RightHand and parts.LeftUpperLeg and parts.LeftLowerLeg and parts.LeftFoot and parts.RightUpperLeg and parts.RightLowerLeg and parts.RightFoot) then
                ClearSkeleton(player)
                continue
            end

            local headPos, headOnScreen = camera:WorldToViewportPoint(parts.Head.Position)
            local neckPos, neckOnScreen = camera:WorldToViewportPoint(parts.Neck.Position)
            local upperTorsoPos, upperTorsoOnScreen = camera:WorldToViewportPoint(parts.UpperTorso.Position)
            local lowerTorsoPos, lowerTorsoOnScreen = camera:WorldToViewportPoint(parts.LowerTorso.Position)
            local leftUpperArmPos, leftUpperArmOnScreen = camera:WorldToViewportPoint(parts.LeftUpperArm.Position)
            local leftLowerArmPos, leftLowerArmOnScreen = camera:WorldToViewportPoint(parts.LeftLowerArm.Position)
            local leftHandPos, leftHandOnScreen = camera:WorldToViewportPoint(parts.LeftHand.Position)
            local rightUpperArmPos, rightUpperArmOnScreen = camera:WorldToViewportPoint(parts.RightUpperArm.Position)
            local rightLowerArmPos, rightLowerArmOnScreen = camera:WorldToViewportPoint(parts.RightLowerArm.Position)
            local rightHandPos, rightHandOnScreen = camera:WorldToViewportPoint(parts.RightHand.Position)
            local leftUpperLegPos, leftUpperLegOnScreen = camera:WorldToViewportPoint(parts.LeftUpperLeg.Position)
            local leftLowerLegPos, leftLowerLegOnScreen = camera:WorldToViewportPoint(parts.LeftLowerLeg.Position)
            local leftFootPos, leftFootOnScreen = camera:WorldToViewportPoint(parts.LeftFoot.Position)
            local rightUpperLegPos, rightUpperLegOnScreen = camera:WorldToViewportPoint(parts.RightUpperLeg.Position)
            local rightLowerLegPos, rightLowerLegOnScreen = camera:WorldToViewportPoint(parts.RightLowerLeg.Position)
            local rightFootPos, rightFootOnScreen = camera:WorldToViewportPoint(parts.RightFoot.Position)

            if headOnScreen and neckOnScreen then
                skeleton.HeadToNeck.From = Vector2.new(headPos.X, headPos.Y)
                skeleton.HeadToNeck.To = Vector2.new(neckPos.X, neckPos.Y)
                skeleton.HeadToNeck.Visible = true
            else
                skeleton.HeadToNeck.Visible = false
            end

            if neckOnScreen and upperTorsoOnScreen then
                skeleton.NeckToUpperTorso.From = Vector2.new(neckPos.X, neckPos.Y)
                skeleton.NeckToUpperTorso.To = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.NeckToUpperTorso.Visible = true
            else
                skeleton.NeckToUpperTorso.Visible = false
            end

            if upperTorsoOnScreen and lowerTorsoOnScreen then
                skeleton.UpperTorsoToLowerTorso.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToLowerTorso.To = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.UpperTorsoToLowerTorso.Visible = true
            else
                skeleton.UpperTorsoToLowerTorso.Visible = false
            end

            if upperTorsoOnScreen and leftUpperArmOnScreen then
                skeleton.UpperTorsoToLeftUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToLeftUpperArm.To = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
                skeleton.UpperTorsoToLeftUpperArm.Visible = true
            else
                skeleton.UpperTorsoToLeftUpperArm.Visible = false
            end

            if leftUpperArmOnScreen and leftLowerArmOnScreen then
                skeleton.LeftUpperArmToLeftLowerArm.From = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
                skeleton.LeftUpperArmToLeftLowerArm.To = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
                skeleton.LeftUpperArmToLeftLowerArm.Visible = true
            else
                skeleton.LeftUpperArmToLeftLowerArm.Visible = false
            end

            if leftLowerArmOnScreen and leftHandOnScreen then
                skeleton.LeftLowerArmToLeftHand.From = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
                skeleton.LeftLowerArmToLeftHand.To = Vector2.new(leftHandPos.X, leftHandPos.Y)
                skeleton.LeftLowerArmToLeftHand.Visible = true
            else
                skeleton.LeftLowerArmToLeftHand.Visible = false
            end

            if upperTorsoOnScreen and rightUpperArmOnScreen then
                skeleton.UpperTorsoToRightUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
                skeleton.UpperTorsoToRightUpperArm.To = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
                skeleton.UpperTorsoToRightUpperArm.Visible = true
            else
                skeleton.UpperTorsoToRightUpperArm.Visible = false
            end

            if rightUpperArmOnScreen and rightLowerArmOnScreen then
                skeleton.RightUpperArmToRightLowerArm.From = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
                skeleton.RightUpperArmToRightLowerArm.To = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
                skeleton.RightUpperArmToRightLowerArm.Visible = true
            else
                skeleton.RightUpperArmToRightLowerArm.Visible = false
            end

            if rightLowerArmOnScreen and rightHandOnScreen then
                skeleton.RightLowerArmToRightHand.From = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
                skeleton.RightLowerArmToRightHand.To = Vector2.new(rightHandPos.X, rightHandPos.Y)
                skeleton.RightLowerArmToRightHand.Visible = true
            else
                skeleton.RightLowerArmToRightHand.Visible = false
            end

            if lowerTorsoOnScreen and leftUpperLegOnScreen then
                skeleton.LowerTorsoToLeftUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.LowerTorsoToLeftUpperLeg.To = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
                skeleton.LowerTorsoToLeftUpperLeg.Visible = true
            else
                skeleton.LowerTorsoToLeftUpperLeg.Visible = false
            end

            if leftUpperLegOnScreen and leftLowerLegOnScreen then
                skeleton.LeftUpperLegToLeftLowerLeg.From = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
                skeleton.LeftUpperLegToLeftLowerLeg.To = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
                skeleton.LeftUpperLegToLeftLowerLeg.Visible = true
            else
                skeleton.LeftUpperLegToLeftLowerLeg.Visible = false
            end

            if leftLowerLegOnScreen and leftFootOnScreen then
                skeleton.LeftLowerLegToLeftFoot.From = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
                skeleton.LeftLowerLegToLeftFoot.To = Vector2.new(leftFootPos.X, leftFootPos.Y)
                skeleton.LeftLowerLegToLeftFoot.Visible = true
            else
                skeleton.LeftLowerLegToLeftFoot.Visible = false
            end

            if lowerTorsoOnScreen and rightUpperLegOnScreen then
                skeleton.LowerTorsoToRightUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
                skeleton.LowerTorsoToRightUpperLeg.To = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
                skeleton.LowerTorsoToRightUpperLeg.Visible = true
            else
                skeleton.LowerTorsoToRightUpperLeg.Visible = false
            end

            if rightUpperLegOnScreen and rightLowerLegOnScreen then
                skeleton.RightUpperLegToRightLowerLeg.From = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
                skeleton.RightUpperLegToRightLowerLeg.To = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
                skeleton.RightUpperLegToRightLowerLeg.Visible = true
            else
                skeleton.RightUpperLegToRightLowerLeg.Visible = false
            end

            if rightLowerLegOnScreen and rightFootOnScreen then
                skeleton.RightLowerLegToRightFoot.From = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
                skeleton.RightLowerLegToRightFoot.To = Vector2.new(rightFootPos.X, rightFootPos.Y)
                skeleton.RightLowerLegToRightFoot.Visible = true
            else
                skeleton.RightLowerLegToRightFoot.Visible = false
            end
        else
            ClearSkeleton(player)
        end
    end
end

local function UpdateHealthESP()
    if not State.HealthESPEnabled then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in next, Players:GetChildren() do
        if player:IsA('Player') then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            local distance = character and character:FindFirstChild('HumanoidRootPart') and (localRoot.Position - character.HumanoidRootPart.Position).Magnitude or math.huge
            if not ShouldShowPlayer(player, character, distance) then
                ClearHealthESP(player)
                continue
            end

            if not Caches.HealthCache[player] then
                Caches.HealthCache[player] = CreateHealthESP(player)
            end

            local health = Caches.HealthCache[player]
            local headPos, onScreen = camera:WorldToViewportPoint(character.HumanoidRootPart.Position - Vector3.new(0, 3, 0))
            if onScreen then
                local healthPercentage = character.Humanoid.Health / character.Humanoid.MaxHealth
                health.BarBackground.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
                health.BarBackground.Visible = true
                health.Bar.Size = Vector2.new(50 * healthPercentage, 5)
                health.Bar.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
                health.Bar.Color = Color3.new(1 - healthPercentage, healthPercentage, 0)
                health.Bar.Visible = true
                health.Text.Text = tostring(math.floor(healthPercentage * 100)) .. "%"
                health.Text.Position = Vector2.new(headPos.X, headPos.Y - 45)
                health.Text.Visible = true
            else
                health.BarBackground.Visible = false
                health.Bar.Visible = false
                health.Text.Visible = false
            end
        else
            ClearHealthESP(player)
        end
    end
end

local function UpdateTracerESP()
    if not State.TracerESPEnabled then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    local screenSize = camera.ViewportSize
    local tracerFrom
    if Config.TracerOrigin == 'Bottom Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, screenSize.Y)
    elseif Config.TracerOrigin == 'Cursor' then
        tracerFrom = UserInputService:GetMouseLocation()
    elseif Config.TracerOrigin == 'Top Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, 0)
    end

    for _, player in next, Players:GetChildren() do
        if player:IsA('Player') then
            local character = getupvalue(bac_characters_senv.NewChar, 1)[player]
            local distance = character and character:FindFirstChild('HumanoidRootPart') and (localRoot.Position - character.HumanoidRootPart.Position).Magnitude or math.huge
            if not ShouldShowPlayer(player, character, distance) then
                ClearTracer(player)
                continue
            end

            local targetHead = character:FindFirstChild("Head") or character.HumanoidRootPart
            if not Caches.TracerCache[player] then
                Caches.TracerCache[player] = CreateTracer(player)
            end

            local tracer = Caches.TracerCache[player]
            local headPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
            tracer.From = tracerFrom
            tracer.To = Vector2.new(headPos.X, headPos.Y)
            tracer.Visible = onScreen
        else
            ClearTracer(player)
        end
    end
end

Players.PlayerRemoving:Connect(function(player)
    SafeExecute(function()
        ClearESP(player)
        ClearSkeleton(player)
        ClearHealthESP(player)
        ClearTracer(player)
    end, "PlayerRemoving")
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        character.AncestryChanged:Connect(function()
            if not character:IsDescendantOf(Workspace) then
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end, "CharacterAncestryChanged")
            end
        end)
        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.Died:Connect(function()
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end, "HumanoidDied")
            end)
        end
    end)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        State.AimbotLocking = true
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        State.AimbotLocking = false
    end
end)

local Window = Library:CreateWindow({
    Title = 'Rush Point X | By zixy.py2',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
})

local Tabs = {
    Legit = Window:AddTab('Legit'),
    Rage = Window:AddTab('Rage'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    Exploits = Window:AddTab('Exploits'),
    Settings = Window:AddTab('UI Settings'),
}

local LegitGroup = Tabs.Legit:AddLeftGroupbox('Legit Controls')

LegitGroup:AddToggle('AimbotToggle', {
    Text = 'Enable Aimbot',
    Default = false,
    Callback = function(Value)
        State.AimbotEnabled = Value
        if not State.AimbotEnabled then
            State.AimbotLocking = false
        end
    end,
})

LegitGroup:AddToggle('AimbotFOVToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(Value)
        State.AimbotFOVEnabled = Value
        if not State.AimbotFOVEnabled and State.AimbotFOVCircle then
            State.AimbotFOVCircle.Visible = false
        end
    end,
})

LegitGroup:AddToggle('Aimbot360FOVToggle', {
    Text = '360 FOV',
    Default = false,
    Callback = function(Value)
        State.Aimbot360FOV = Value
        if State.Aimbot360FOV then
            State.AimbotFOVEnabled = false
            if State.AimbotFOVCircle then
                State.AimbotFOVCircle.Visible = false
            end
        end
    end,
})

LegitGroup:AddSlider('AimbotFOVSizeSlider', {
    Text = 'FOV Size',
    Default = Config.AimbotFOVRadius,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Callback = function(Value)
        Config.AimbotFOVRadius = Value
    end,
})

LegitGroup:AddSlider('AimbotSmoothingSlider', {
    Text = 'Smoothing',
    Default = Config.AimbotSmoothing,
    Min = 0,
    Max = 25,
    Rounding = 0,
    Callback = function(Value)
        Config.AimbotSmoothing = Value
    end,
})

LegitGroup:AddDropdown('AimbotHitPartDropdown', {
    Text = 'Aimbot Hit Part',
    Default = Config.AimbotHitPart,
    Values = {'Head', 'UpperTorso', 'LowerTorso'},
    Callback = function(Value)
        Config.AimbotHitPart = Value
    end,
})

local RageGroup = Tabs.Rage:AddLeftGroupbox('Rage Controls')

RageGroup:AddToggle('SilentAimToggle', {
    Text = 'Enable Silent Aim',
    Default = false,
    Callback = function(Value)
        State.SilentAimEnabled = Value
    end,
})

RageGroup:AddToggle('SilentAimFOVToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(Value)
        State.SilentAimFOVEnabled = Value
        if not State.SilentAimFOVEnabled and State.SilentAimFOVCircle then
            State.SilentAimFOVCircle.Visible = false
        end
    end,
})

RageGroup:AddToggle('SilentAim360FOVToggle', {
    Text = '360 FOV',
    Default = false,
    Callback = function(Value)
        State.SilentAim360FOV = Value
        if State.SilentAim360FOV then
            State.SilentAimFOVEnabled = false
            if State.SilentAimFOVCircle then
                State.SilentAimFOVCircle.Visible = false
            end
        end
    end,
})

RageGroup:AddSlider('SilentAimFOVSizeSlider', {
    Text = 'FOV Size',
    Default = Config.SilentAimFOVRadius,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        Config.SilentAimFOVRadius = Value
    end,
})

RageGroup:AddSlider('SilentAimHitchanceSlider', {
    Text = 'Silent Aim Hitchance',
    Default = Config.SilentAimHitchance,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Suffix = '%',
    Callback = function(Value)
        Config.SilentAimHitchance = Value
    end,
})

RageGroup:AddToggle('VisibleCheckToggle', {
    Text = 'Visible Check',
    Default = false,
    Callback = function(Value)
        State.VisibleCheckEnabled = Value
    end,
})

RageGroup:AddToggle('RagebotToggle', {
    Text = 'Enable Ragebot',
    Default = false,
    Callback = function(Value)
        State.RagebotEnabled = Value
        if not State.RagebotEnabled and State.IsRagebotShooting then
            State.IsRagebotShooting = false
        end
    end,
})

RageGroup:AddDropdown('SilentAimHitPartDropdown', {
    Text = 'Silent Aim Hit Part',
    Default = Config.SilentAimHitPart,
    Values = {'Head', 'UpperTorso', 'LowerTorso'},
    Callback = function(Value)
        Config.SilentAimHitPart = Value
    end,
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('Visual Controls')

VisualsGroup:AddToggle('ESPCustomToggle', {
    Text = 'Box ESP',
    Default = false,
    Callback = function(Value)
        State.ESPCustomEnabled = Value
        if not State.ESPCustomEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Box.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('NameESPToggle', {
    Text = 'Name ESP',
    Default = false,
    Callback = function(Value)
        State.NameESPEnabled = Value
        if not State.NameESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Name.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('DistanceESPToggle', {
    Text = 'Distance ESP',
    Default = false,
    Callback = function(Value)
        State.DistanceESPEnabled = Value
        if not State.DistanceESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Distance.Visible = false
            end
        end
    end,
})

VisualsGroup:AddToggle('SkeletonESPToggle', {
    Text = 'Skeleton ESP',
    Default = false,
    Callback = function(Value)
        State.SkeletonESPEnabled = Value
        if not State.SkeletonESPEnabled then
            for player, _ in pairs(Caches.SkeletonCache) do
                ClearSkeleton(player)
            end
        end
    end,
})

VisualsGroup:AddToggle('HealthESPToggle', {
    Text = 'Health ESP',
    Default = false,
    Callback = function(Value)
        State.HealthESPEnabled = Value
        if not State.HealthESPEnabled then
            for player, _ in pairs(Caches.HealthCache) do
                ClearHealthESP(player)
            end
        end
    end,
})

VisualsGroup:AddToggle('TracerESPToggle', {
    Text = 'Tracer ESP',
    Default = false,
    Callback = function(Value)
        State.TracerESPEnabled = Value
        if not State.TracerESPEnabled then
            for player, _ in pairs(Caches.TracerCache) do
                ClearTracer(player)
            end
        end
    end,
})

VisualsGroup:AddDropdown('TracerOriginDropdown', {
    Text = 'Tracer Origin',
    Default = Config.TracerOrigin,
    Values = {'Bottom Screen', 'Cursor', 'Top Screen'},
    Callback = function(Value)
        Config.TracerOrigin = Value
    end,
})

VisualsGroup:AddToggle('ESPTeamCheckToggle', {
    Text = 'Team Check',
    Default = Config.TeamCheck,
    Tooltip = 'Only show ESP for enemy players',
    Callback = function(Value)
        Config.TeamCheck = Value
        SaveManager:Save('RushPointXConfig')
    end,
})

local PlayerGroup = Tabs.Player:AddLeftGroupbox('Player Controls')

PlayerGroup:AddToggle('NoclipToggle', {
    Text = 'Enable Noclip',
    Default = false,
    Callback = function(Value)
        State.NoclipEnabled = Value
        UpdateNoclip()
    end,
})

local ExploitsGroup = Tabs.Exploits:AddLeftGroupbox('Exploit Controls')

ExploitsGroup:AddToggle('RainbowGunToggle', {
    Text = 'Rainbow Gun Chams',
    Default = false,
    Tooltip = 'Applies a rainbow effect to the gun with ForceField material',
    Callback = function(Value)
        State.RainbowGunEnabled = Value
        if Value then
            State.CustomGunColorEnabled = false
            StartRainbowEffect()
        else
            if State.RainbowTask then
                task.cancel(State.RainbowTask)
                State.RainbowTask = nil
            end
            ResetGunAppearance()
        end
        UpdateGunAppearance()
    end,
})

ExploitsGroup:AddToggle('CustomGunColorToggle', {
    Text = 'Custom Gun Chams',
    Default = false,
    Tooltip = 'Applies a custom color and transparency to the gun with ForceField material',
    Callback = function(Value)
        State.CustomGunColorEnabled = Value
        if Value then
            State.RainbowGunEnabled = false
        end
        UpdateGunAppearance()
    end,
})

ExploitsGroup:AddLabel('CustomGunColorPicker'):AddColorPicker('ColorPicker', {
    Text = 'Gun Color',
    Default = Config.CustomGunColor,
    Callback = function(Value)
        Config.CustomGunColor = Value
        if State.CustomGunColorEnabled then
            UpdateGunAppearance()
        end
    end,
})

ExploitsGroup:AddSlider('CustomGunTransparencySlider', {
    Text = 'Gun Transparency',
    Default = Config.CustomGunTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        Config.CustomGunTransparency = Value
        if State.CustomGunColorEnabled then
            UpdateGunAppearance()
        end
    end,
})

ExploitsGroup:AddToggle('NoRecoilToggle', {
    Text = 'No Recoil',
    Default = false,
    Tooltip = 'Disables weapon recoil',
    Callback = function(Value)
        State.NoRecoilEnabled = Value
        SaveManager:Save('RushPointXConfig')
    end,
})

ExploitsGroup:AddToggle('NoSpreadToggle', {
    Text = 'No Spread',
    Default = false,
    Tooltip = 'Disables weapon spread',
    Callback = function(Value)
        State.NoSpreadEnabled = Value
        if Value and not State.NoSpreadTask then
            State.NoSpreadTask = coroutine.wrap(function()
                while State.NoSpreadEnabled do
                    local ModuleLoader = require(game:GetService("ReplicatedStorage").Modules.Shared.ModuleLoader)
                    local LoadedModules = ModuleLoader.LoadedModules
                    local WeaponInfo = LoadedModules.WeaponInfo
                    for _, value in next, WeaponInfo do
                        if type(value) == 'table' then
                            value['Spread'] = 0
                            value['MovementSpreadTime'] = 0
                            value['MovementSpreadPenalty'] = 0
                        end
                    end
                    wait(0.1)
                end
            end)()
        elseif not Value and State.NoSpreadTask then
            State.NoSpreadTask = nil
        end
        SaveManager:Save('RushPointXConfig')
    end,
})
ExploitsGroup:AddToggle('RapidFireToggle', {
    Text = 'Rapid Fire',
    Default = false,
    Callback = function(Value)
        State.RapidFireEnabled = Value
        if Value then
            State.RapidFireTask = task.spawn(function()
                while State.RapidFireEnabled do
                    local ModuleLoader = require(game:GetService("ReplicatedStorage").Modules.Shared.ModuleLoader)
                    local WeaponInfo = ModuleLoader.LoadedModules.WeaponInfo
                    for _, value in next, WeaponInfo do
                        if type(value) == 'table' then
                            value['FireRate'] = 0.01
                        end
                    end
                    task.wait(0.1)
                end
            end)
        else
            if State.RapidFireTask then
                task.cancel(State.RapidFireTask)
                State.RapidFireTask = nil
            end
        end
    end,
})
local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end,
    Tooltip = 'Unloads the script',
})

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Text = 'Menu keybind',
    Default = 'RightShift',
    NoUI = true,
})

Library.ToggleKeybind = Options.MenuKeybind

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Rush Point X | Made by zixy.py2')

Library:OnUnload(function()
    if State.SilentAimFOVCircle then
        State.SilentAimFOVCircle:Remove()
    end
    if State.AimbotFOVCircle then
        State.AimbotFOVCircle:Remove()
    end
    if State.FlyReinitializeConnection then
        State.FlyReinitializeConnection = nil
    end
    if State.FlyConnection then
        State.FlyConnection:Disconnect()
        State.FlyConnection = nil
    end
    if State.WeaponConnection then
        State.WeaponConnection:Disconnect()
        State.WeaponConnection = nil
    end
    if State.NoSpreadTask then
        State.NoSpreadTask = nil
    end
    if State.RainbowTask then
        task.cancel(State.RainbowTask)
        State.RainbowTask = nil
    end
    network.FireServer = old
    recoil.AddRecoil = oldRecoil
    State.FlyEnabled = false
    State.NoclipEnabled = false
    State.InfiniteJumpEnabled = false
    State.ESPCustomEnabled = false
    State.NameESPEnabled = false
    State.DistanceESPEnabled = false
    State.SkeletonESPEnabled = false
    State.HealthESPEnabled = false
    State.TracerESPEnabled = false
    State.NoRecoilEnabled = false
    State.RapidFireEnabled = false
    State.NoSpreadEnabled = false
    State.WalkSpeedEnabled = false
    State.JumpPowerEnabled = false
    State.RagebotEnabled = false
    State.IsRagebotShooting = false
    State.VisibleCheckEnabled = false
    State.SilentAim360FOV = false
    State.Aimbot360FOV = false
    State.RainbowGunEnabled = false
    State.CustomGunColorEnabled = false
    UpdateFly()
    UpdateNoclip()
    UpdateInfiniteJump()
    UpdateESP()
    UpdateSkeletonESP()
    UpdateHealthESP()
    UpdateTracerESP()
    if State.RainbowGunEnabled or State.CustomGunColorEnabled then
        ResetGunAppearance()
    end
    Library.Unloaded = true
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Library:Notify(
    'Cheat Loaded',
    'Rush Point X is ready! Press RightShift to toggle GUI.',
    5
)

coroutine.wrap(function()
    local attempts = 0
    while not LocalPlayer.Character and attempts < 50 do
        wait(0.1)
        attempts = attempts + 1
    end
    if LocalPlayer.Character then
        SafeExecute(UpdateMovement, "Initial Movement Update")
    end
end)()

RunService.RenderStepped:Connect(function()
    SafeExecute(UpdateFOVCircle, "UpdateFOVCircle")
    SafeExecute(UpdateNoclip, "UpdateNoclip")
    SafeExecute(UpdateESP, "UpdateESP")
    SafeExecute(UpdateSkeletonESP, "UpdateSkeletonESP")
    SafeExecute(UpdateHealthESP, "UpdateHealthESP")
    SafeExecute(UpdateTracerESP, "UpdateTracerESP")
    SafeExecute(UpdateAimbot, "UpdateAimbot")
    SafeExecute(UpdateMovement, "UpdateMovement")
    SafeExecute(UpdateRagebot, "UpdateRagebot")
    -- Reapply gun appearance if toggles are active
    if State.RainbowGunEnabled or State.CustomGunColorEnabled then
        SafeExecute(UpdateGunAppearance, "UpdateGunAppearance on RenderStepped")
    end
end)
