local players = game:GetService("Players")
local player = players.LocalPlayer
local rs = game:GetService("RunService")
local camera = workspace.CurrentCamera
local replicated = game:GetService("ReplicatedStorage")
local physics = game:GetService("PhysicsService")
local UserInputService = game:GetService('UserInputService')

local silentaim = false
local noforcefields = false
local norecoil = false
local infiniteammo = false
local fovcircle = false
local fovradius = 100
local hitchance = 100
local hitpart = "Head"
local aimbotEnabled = false
local aimbotFOVEnabled = false
local aimbot360FOV = false
local aimbotSmoothing = 0
local predictionEnabled = false
local triggerbotEnabled = false
local isTriggerbotShooting = false
local espCustomEnabled = false
local nameESPEnabled = false
local distanceESPEnabled = false
local skeletonESPEnabled = false
local healthESPEnabled = false
local tracerESPEnabled = false
local chamsEnabled = false
local espDistance = 325
local aimbotFOVRadius = 100
local fovColor = Color3.fromRGB(255, 255, 255)
local skeletonESPColor = Color3.new(0.403922, 0.349020, 0.701961)
local tracerOrigin = 'Bottom Screen'
local chamsColor = Color3.new(1, 0, 0)
local ragebotEnabled = false
local isRagebotShooting = false
local teamCheck = true
local projectileSpeed = 1000

local weapons, camos = {}, {}
for _, v in pairs(replicated.Weapons:GetChildren()) do table.insert(weapons, v.Name) end
for _, v in pairs(replicated.Camos:GetChildren()) do table.insert(camos, v.Name) end

local primary, secondary, primarycamo, secondarycamo

local vortex = player:WaitForChild("PlayerScripts"):WaitForChild("Vortex")
local s = vortex.Modifiers:FindFirstChild("Steadiness")
local m = vortex.Modifiers:FindFirstChild("Mobility")

local function removeRecoil()
    if norecoil then
        if s and s.Value > 0 then s.Value = 0 end
        if m and m.Value > 0 then m.Value = 0 end
    end
end
if s then s.Changed:Connect(removeRecoil) end
if m then m.Changed:Connect(removeRecoil) end

local oldIndex
oldIndex = hookmetamethod(game, "__index", function(self, prop)
    if infiniteammo and tostring(self) == "StoredAmmo" and prop == "Value" then
        return math.huge
    end
    return oldIndex(self, prop)
end)

rs.RenderStepped:Connect(function()
    if infiniteammo and vortex.Enabled then
        local restock = getsenv(vortex).Restock
        if restock then restock() end
    end
end)

rs.RenderStepped:Connect(function()
    if noforcefields then
        for _, v in pairs(workspace.Env:GetChildren()) do
            if v:IsA("Model") and v:FindFirstChild("FullSphere") and v.Name:find("Forcefield") then
                if v.FullSphere.Color ~= Color3.fromRGB(0, 102, 255) then
                    v:Destroy()
                end
            end
        end
    end
end)

local Drawing = Drawing
local vector2 = Vector2.new
local c_workspace = game:GetService("Workspace")
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fovradius
fovCircle.Visible = false
fovCircle.Color = fovColor
fovCircle.Thickness = 2
fovCircle.Transparency = 1
fovCircle.Filled = false
fovCircle.Position = UserInputService:GetMouseLocation()

local aimbotFOVCircle = Drawing.new("Circle")
aimbotFOVCircle.Radius = aimbotFOVRadius
aimbotFOVCircle.Visible = false
aimbotFOVCircle.Color = fovColor
aimbotFOVCircle.Thickness = 2
aimbotFOVCircle.Transparency = 1
aimbotFOVCircle.Filled = false
aimbotFOVCircle.Position = UserInputService:GetMouseLocation()

local espCache = {}
local skeletonCache = {}
local healthCache = {}
local tracerCache = {}
local chamsCache = {}

local function isPlayerVisible(target)
    if not target or not target:FindFirstChild(hitpart) then return false end
    local origin = camera.CFrame.Position
    local targetPos = target[hitpart].Position
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local raycastResult = workspace:Raycast(origin, targetPos - origin, raycastParams)
    return not raycastResult or raycastResult.Instance:IsDescendantOf(target)
end

local function predictPosition(target)
    if not predictionEnabled or not target or not target:FindFirstChild(hitpart) or not target:FindFirstChild("HumanoidRootPart") then
        return target and target[hitpart].Position
    end
    local velocity = target.HumanoidRootPart.Velocity
    local distance = (player.Character.HumanoidRootPart.Position - target[hitpart].Position).Magnitude
    local travel_time = distance / projectileSpeed
    return target[hitpart].Position + (velocity * travel_time)
end

local function getClosestPlayer()
    local closest, distance = nil, fovradius
    for _, character in c_workspace:GetChildren() do
        if character and character:FindFirstChild("Head") then
            local actualPlayer = players:GetPlayerFromCharacter(character) or character
            if actualPlayer == player then continue end
            if not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then continue end
            local humanoid = character.Humanoid
            if humanoid.Health <= 0 then continue end
            local team_attribute = actualPlayer:GetAttribute("Team")
            if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then continue end
            local w2s, onscreen = camera:WorldToViewportPoint(character.Head.Position)
            if onscreen then
                local dist = (vector2(w2s.X, w2s.Y) - (camera.ViewportSize / 2)).Magnitude
                if dist < distance and dist <= fovradius then
                    closest = character
                    distance = dist
                end
            end
        end
    end
    return closest
end

local closest_player = nil

rs.RenderStepped:Connect(function()
    fovCircle.Position = camera.ViewportSize / 2
    fovCircle.Radius = fovradius
    fovCircle.Visible = fovcircle

    aimbotFOVCircle.Position = camera.ViewportSize / 2
    aimbotFOVCircle.Radius = aimbotFOVRadius
    aimbotFOVCircle.Visible = aimbotFOVEnabled and not aimbot360FOV

    if silentaim then
        closest_player = getClosestPlayer()
    else
        closest_player = nil
    end

    if aimbotEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local closest = getClosestPlayer(aimbotFOVRadius, true)
        if closest and closest:FindFirstChild("Head") then
            local target_pos = predictPosition(closest) or closest.Head.Position
            local headPos, onScreen = camera:WorldToViewportPoint(target_pos)
            if onScreen then
                local mousePos = UserInputService:GetMouseLocation()
                local delta = vector2(headPos.X, headPos.Y) - mousePos
                local smoothingFactor = ((25 - aimbotSmoothing) / 50) ^ 2
                local smoothedDelta = delta * smoothingFactor
                mousemoverel(smoothedDelta.X, smoothedDelta.Y)
            end
        end
    end

    if triggerbotEnabled and player.Character and player.Character:FindFirstChild('HumanoidRootPart') then
        local closest = getClosestPlayer(aimbotFOVRadius, false)
        if closest and closest:FindFirstChild('HumanoidRootPart') and closest:FindFirstChild(hitpart) then
            local mousePos = UserInputService:GetMouseLocation()
            local hitPart = closest[hitpart]
            local isVisible = isPlayerVisible(closest)
            local screenPos, onScreen = camera:WorldToViewportPoint(hitPart.Position)
            local cursorOverHitPart = false
            if onScreen then
                local hitPartSize = hitPart.Size.Magnitude * 10
                local distance = (vector2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distance < hitPartSize then
                    cursorOverHitPart = true
                end
            end
            if cursorOverHitPart and isVisible then
                if not isTriggerbotShooting then
                    mouse1press()
                    isTriggerbotShooting = true
                end
            else
                if isTriggerbotShooting then
                    mouse1release()
                    isTriggerbotShooting = false
                end
            end
        else
            if isTriggerbotShooting then
                mouse1release()
                isTriggerbotShooting = false
            end
        end
    end

    if ragebotEnabled and player.Character then
        local closest = getClosestPlayer(fovradius, false)
        if closest and closest:FindFirstChild(hitpart) then
            local _, onScreen = camera:WorldToViewportPoint(closest[hitpart].Position)
            local isVisible = isPlayerVisible(closest)
            if onScreen and isVisible then
                silentaim = true
                if not isRagebotShooting then
                    mouse1press()
                    isRagebotShooting = true
                end
            else
                if isRagebotShooting then
                    mouse1release()
                    isRagebotShooting = false
                end
            end
        else
            if isRagebotShooting then
                mouse1release()
                isRagebotShooting = false
            end
        end
    end
end)

local getinfo = debug.getinfo
local cframenew = CFrame.new

local old_index
old_index = hookmetamethod(game, "__index", function(self, index)
    local info = getinfo(3, "n")
    if info and info.name == "Fire" and index == "CFrame" and silentaim and closest_player and closest_player:FindFirstChild(hitpart) then
        return cframenew(closest_player[hitpart].Position)
    end
    return old_index(self, index)
end)

local function createESP(character)
    local esp = {
        Box = Drawing.new('Square'),
        Name = Drawing.new('Text'),
        Distance = Drawing.new('Text'),
    }
    esp.Box.Thickness = 2
    esp.Box.Color = Color3.new(0.403922, 0.349020, 0.701961)
    esp.Box.Filled = false
    esp.Box.Visible = false
    esp.Name.Size = 16
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Outline = true
    esp.Name.Center = true
    esp.Name.Visible = false
    esp.Distance.Size = 16
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Outline = true
    esp.Distance.Center = true
    esp.Distance.Visible = false
    return esp
end

local function createSkeleton(character)
    local skeleton = {
        HeadToNeck = Drawing.new('Line'),
        NeckToUpperTorso = Drawing.new('Line'),
        UpperTorsoToLowerTorso = Drawing.new('Line'),
        UpperTorsoToLeftUpperArm = Drawing.new('Line'),
        LeftUpperArmToLeftLowerArm = Drawing.new('Line'),
        LeftLowerArmToLeftHand = Drawing.new('Line'),
        UpperTorsoToRightUpperArm = Drawing.new('Line'),
        RightUpperArmToRightLowerArm = Drawing.new('Line'),
        RightLowerArmToRightHand = Drawing.new('Line'),
        LowerTorsoToLeftUpperLeg = Drawing.new('Line'),
        LeftUpperLegToLeftLowerLeg = Drawing.new('Line'),
        LeftLowerLegToLeftFoot = Drawing.new('Line'),
        LowerTorsoToRightUpperLeg = Drawing.new('Line'),
        RightUpperLegToRightLowerLeg = Drawing.new('Line'),
        RightLowerLegToRightFoot = Drawing.new('Line'),
    }
    for _, line in pairs(skeleton) do
        line.Thickness = 2
        line.Color = skeletonESPColor
        line.Visible = false
    end
    return skeleton
end

local function createHealthESP(character)
    local health = {
        BarBackground = Drawing.new('Square'),
        Bar = Drawing.new('Square'),
        Text = Drawing.new('Text'),
    }
    health.BarBackground.Size = vector2(50, 5)
    health.BarBackground.Color = Color3.new(0, 0, 0)
    health.BarBackground.Filled = true
    health.BarBackground.Transparency = 0.5
    health.BarBackground.Visible = false
    health.Bar.Size = vector2(50, 5)
    health.Bar.Color = Color3.new(0, 1, 0)
    health.Bar.Filled = true
    health.Bar.Visible = false
    health.Text.Size = 12
    health.Text.Color = Color3.new(1, 1, 1)
    health.Text.Outline = true
    health.Text.Center = true
    health.Text.Visible = false
    return health
end

local function createTracer(character)
    local tracer = Drawing.new('Line')
    tracer.Thickness = 2
    tracer.Color = Color3.new(0.403922, 0.349020, 0.701961)
    tracer.Visible = false
    return tracer
end

local function createChams(character)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = chamsColor
    highlight.OutlineColor = Color3.new(1, 1, 1)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character
    highlight.Adornee = character
    return highlight
end

local function clearESP(character)
    if espCache[character] then
        espCache[character].Box:Remove()
        espCache[character].Name:Remove()
        espCache[character].Distance:Remove()
        espCache[character] = nil
    end
end

local function clearSkeleton(character)
    if skeletonCache[character] then
        for _, line in pairs(skeletonCache[character]) do
            line:Remove()
        end
        skeletonCache[character] = nil
    end
end

local function clearHealthESP(character)
    if healthCache[character] then
        healthCache[character].BarBackground:Remove()
        healthCache[character].Bar:Remove()
        healthCache[character].Text:Remove()
        healthCache[character] = nil
    end
end

local function clearTracer(character)
    if tracerCache[character] then
        tracerCache[character]:Remove()
        tracerCache[character] = nil
    end
end

local function clearChams(character)
    if chamsCache[character] then
        chamsCache[character]:Destroy()
        chamsCache[character] = nil
    end
end

local function updateESP()
    if not (espCustomEnabled or nameESPEnabled or distanceESPEnabled) then
        for character, _ in pairs(espCache) do
            clearESP(character)
        end
        return
    end
    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        for character, _ in pairs(espCache) do
            clearESP(character)
        end
        return
    end
    local localRoot = player.Character.HumanoidRootPart
    for _, character in pairs(c_workspace:GetChildren()) do
        local actualPlayer = players:GetPlayerFromCharacter(character) or character
        if actualPlayer == player then continue end
        if not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
            clearESP(character)
            continue
        end
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            clearESP(character)
            continue
        end
        local team_attribute = actualPlayer:GetAttribute("Team")
        if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then
            clearESP(character)
            continue
        end
        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > espDistance then
            clearESP(character)
            continue
        end
        if not espCache[character] then
            espCache[character] = createESP(character)
        end
        local esp = espCache[character]
        local rootPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position)
        if onScreen then
            local head = character:FindFirstChild("Head")
            local topPos = head and camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1, 0)) or camera:WorldToViewportPoint(targetRoot.Position + Vector3.new(0, 3, 0))
            local bottomPos = camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
            local height = math.abs(topPos.Y - bottomPos.Y)
            local width = height * 0.5
            local centerPos = vector2(rootPos.X, (topPos.Y + bottomPos.Y) / 2)
            esp.Box.Size = vector2(width, height)
            esp.Box.Position = centerPos - vector2(width / 2, height / 2)
            esp.Box.Visible = espCustomEnabled
            esp.Name.Text = actualPlayer.Name
            esp.Name.Position = vector2(rootPos.X, topPos.Y - 20)
            esp.Name.Visible = nameESPEnabled
            esp.Distance.Text = tostring(math.floor(distance)) .. " studs"
            esp.Distance.Position = vector2(rootPos.X, bottomPos.Y + 5)
            esp.Distance.Visible = distanceESPEnabled
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
        end
    end
end

local function updateSkeletonESP()
    if not skeletonESPEnabled then
        for character, _ in pairs(skeletonCache) do
            clearSkeleton(character)
        end
        return
    end
    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        for character, _ in pairs(skeletonCache) do
            clearSkeleton(character)
        end
        return
    end
    local localRoot = player.Character.HumanoidRootPart
    for _, character in pairs(c_workspace:GetChildren()) do
        local actualPlayer = players:GetPlayerFromCharacter(character) or character
        if actualPlayer == player then continue end
        if not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
            clearSkeleton(character)
            continue
        end
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            clearSkeleton(character)
            continue
        end
        local team_attribute = actualPlayer:GetAttribute("Team")
        if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then
            clearSkeleton(character)
            continue
        end
        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > espDistance then
            clearSkeleton(character)
            continue
        end
        if not skeletonCache[character] then
            skeletonCache[character] = createSkeleton(character)
        end
        local skeleton = skeletonCache[character]
        local parts = {
            Head = character:FindFirstChild("Head"),
            Neck = character:FindFirstChild("Neck") or character:FindFirstChild("Head"),
            UpperTorso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
            LowerTorso = character:FindFirstChild("LowerTorso") or character:FindFirstChild("HumanoidRootPart"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            LeftFoot = character:FindFirstChild("LeftFoot"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
            RightFoot = character:FindFirstChild("RightFoot"),
        }
        if not (parts.Head and parts.UpperTorso and parts.LowerTorso and parts.LeftUpperArm and parts.LeftLowerArm and parts.LeftHand and parts.RightUpperArm and parts.RightLowerArm and parts.RightHand and parts.LeftUpperLeg and parts.LeftLowerLeg and parts.LeftFoot and parts.RightUpperLeg and parts.RightLowerLeg and parts.RightFoot) then
            clearSkeleton(character)
            continue
        end
        local headPos, headOnScreen = camera:WorldToViewportPoint(parts.Head.Position)
        local neckPos, neckOnScreen = camera:WorldToViewportPoint(parts.Neck.Position)
        local upperTorsoPos, upperTorsoOnScreen = camera:WorldToViewportPoint(parts.UpperTorso.Position)
        local lowerTorsoPos, lowerTorsoOnScreen = camera:WorldToViewportPoint(parts.LowerTorso.Position)
        local leftUpperArmPos, leftUpperArmOnScreen = camera:WorldToViewportPoint(parts.LeftUpperArm.Position)
        local leftLowerArmPos, leftLowerArmOnScreen = camera:WorldToViewportPoint(parts.LeftLowerArm.Position)
        local leftHandPos, leftHandOnScreen = camera:WorldToViewportPoint(parts.LeftHand.Position)
        local rightUpperArmPos, rightUpperArmOnScreen = camera:WorldToViewportPoint(parts.RightUpperArm.Position)
        local rightLowerArmPos, rightLowerArmOnScreen = camera:WorldToViewportPoint(parts.RightLowerArm.Position)
        local rightHandPos, rightHandOnScreen = camera:WorldToViewportPoint(parts.RightHand.Position)
        local leftUpperLegPos, leftUpperLegOnScreen = camera:WorldToViewportPoint(parts.LeftUpperLeg.Position)
        local leftLowerLegPos, leftLowerLegOnScreen = camera:WorldToViewportPoint(parts.LeftLowerLeg.Position)
        local leftFootPos, leftFootOnScreen = camera:WorldToViewportPoint(parts.LeftFoot.Position)
        local rightUpperLegPos, rightUpperLegOnScreen = camera:WorldToViewportPoint(parts.RightUpperLeg.Position)
        local rightLowerLegPos, rightLowerLegOnScreen = camera:WorldToViewportPoint(parts.RightLowerLeg.Position)
        local rightFootPos, rightFootOnScreen = camera:WorldToViewportPoint(parts.RightFoot.Position)
        if headOnScreen and neckOnScreen then
            skeleton.HeadToNeck.From = vector2(headPos.X, headPos.Y)
            skeleton.HeadToNeck.To = vector2(neckPos.X, neckPos.Y)
            skeleton.HeadToNeck.Visible = true
        else
            skeleton.HeadToNeck.Visible = false
        end
        if neckOnScreen and upperTorsoOnScreen then
            skeleton.NeckToUpperTorso.From = vector2(neckPos.X, neckPos.Y)
            skeleton.NeckToUpperTorso.To = vector2(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.NeckToUpperTorso.Visible = true
        else
            skeleton.NeckToUpperTorso.Visible = false
        end
        if upperTorsoOnScreen and lowerTorsoOnScreen then
            skeleton.UpperTorsoToLowerTorso.From = vector2(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.To = vector2(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.Visible = true
        else
            skeleton.UpperTorsoToLowerTorso.Visible = false
        end
        if upperTorsoOnScreen and leftUpperArmOnScreen then
            skeleton.UpperTorsoToLeftUpperArm.From = vector2(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.To = vector2(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.Visible = true
        else
            skeleton.UpperTorsoToLeftUpperArm.Visible = false
        end
        if leftUpperArmOnScreen and leftLowerArmOnScreen then
            skeleton.LeftUpperArmToLeftLowerArm.From = vector2(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.To = vector2(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.Visible = true
        else
            skeleton.LeftUpperArmToLeftLowerArm.Visible = false
        end
        if leftLowerArmOnScreen and leftHandOnScreen then
            skeleton.LeftLowerArmToLeftHand.From = vector2(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftLowerArmToLeftHand.To = vector2(leftHandPos.X, leftHandPos.Y)
            skeleton.LeftLowerArmToLeftHand.Visible = true
        else
            skeleton.LeftLowerArmToLeftHand.Visible = false
        end
        if upperTorsoOnScreen and rightUpperArmOnScreen then
            skeleton.UpperTorsoToRightUpperArm.From = vector2(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToRightUpperArm.To = vector2(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.UpperTorsoToRightUpperArm.Visible = true
        else
            skeleton.UpperTorsoToRightUpperArm.Visible = false
        end
        if rightUpperArmOnScreen and rightLowerArmOnScreen then
            skeleton.RightUpperArmToRightLowerArm.From = vector2(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.To = vector2(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.Visible = true
        else
            skeleton.RightUpperArmToRightLowerArm.Visible = false
        end
        if rightLowerArmOnScreen and rightHandOnScreen then
            skeleton.RightLowerArmToRightHand.From = vector2(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightLowerArmToRightHand.To = vector2(rightHandPos.X, rightHandPos.Y)
            skeleton.RightLowerArmToRightHand.Visible = true
        else
            skeleton.RightLowerArmToRightHand.Visible = false
        end
        if lowerTorsoOnScreen and leftUpperLegOnScreen then
            skeleton.LowerTorsoToLeftUpperLeg.From = vector2(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.To = vector2(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.Visible = true
        else
            skeleton.LowerTorsoToLeftUpperLeg.Visible = false
        end
        if leftUpperLegOnScreen and leftLowerLegOnScreen then
            skeleton.LeftUpperLegToLeftLowerLeg.From = vector2(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.To = vector2(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = true
        else
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = false
        end
        if leftLowerLegOnScreen and leftFootOnScreen then
            skeleton.LeftLowerLegToLeftFoot.From = vector2(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftLowerLegToLeftFoot.To = vector2(leftFootPos.X, leftFootPos.Y)
            skeleton.LeftLowerLegToLeftFoot.Visible = true
        else
            skeleton.LeftLowerLegToLeftFoot.Visible = false
        end
        if lowerTorsoOnScreen and rightUpperLegOnScreen then
            skeleton.LowerTorsoToRightUpperLeg.From = vector2(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.To = vector2(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.Visible = true
        else
            skeleton.LowerTorsoToRightUpperLeg.Visible = false
        end
        if rightUpperLegOnScreen and rightLowerLegOnScreen then
            skeleton.RightUpperLegToRightLowerLeg.From = vector2(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.To = vector2(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.Visible = true
        else
            skeleton.RightUpperLegToRightLowerLeg.Visible = false
        end
        if rightLowerLegOnScreen and rightFootOnScreen then
            skeleton.RightLowerLegToRightFoot.From = vector2(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightLowerLegToRightFoot.To = vector2(rightFootPos.X, rightFootPos.Y)
            skeleton.RightLowerLegToRightFoot.Visible = true
        else
            skeleton.RightLowerLegToRightFoot.Visible = false
        end
    end
end

local function updateHealthESP()
    if not healthESPEnabled then
        for character, _ in pairs(healthCache) do
            clearHealthESP(character)
        end
        return
    end
    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        for character, _ in pairs(healthCache) do
            clearHealthESP(character)
        end
        return
    end
    local localRoot = player.Character.HumanoidRootPart
    for _, character in pairs(c_workspace:GetChildren()) do
        local actualPlayer = players:GetPlayerFromCharacter(character) or character
        if actualPlayer == player then continue end
        if not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
            clearHealthESP(character)
            continue
        end
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            clearHealthESP(character)
            continue
        end
        local team_attribute = actualPlayer:GetAttribute("Team")
        if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then
            clearHealthESP(character)
            continue
        end
        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > espDistance then
            clearHealthESP(character)
            continue
        end
        if not healthCache[character] then
            healthCache[character] = createHealthESP(character)
        end
        local health = healthCache[character]
        local headPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
        if onScreen then
            local healthPercentage = humanoid.Health / humanoid.MaxHealth
            health.BarBackground.Position = vector2(headPos.X - 25, headPos.Y - 30)
            health.BarBackground.Visible = true
            health.Bar.Size = vector2(50 * healthPercentage, 5)
            health.Bar.Position = vector2(headPos.X - 25, headPos.Y - 30)
            health.Bar.Color = Color3.new(1 - healthPercentage, healthPercentage, 0)
            health.Bar.Visible = true
            health.Text.Text = tostring(math.floor(healthPercentage * 100)) .. "%"
            health.Text.Position = vector2(headPos.X, headPos.Y - 45)
            health.Text.Visible = true
        else
            health.BarBackground.Visible = false
            health.Bar.Visible = false
            health.Text.Visible = false
        end
    end
end

local function updateTracerESP()
    if not tracerESPEnabled then
        for character, _ in pairs(tracerCache) do
            clearTracer(character)
        end
        return
    end
    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        for character, _ in pairs(tracerCache) do
            clearTracer(character)
        end
        return
    end
    local localRoot = player.Character.HumanoidRootPart
    local screenSize = camera.ViewportSize
    local tracerFrom
    if tracerOrigin == 'Bottom Screen' then
        tracerFrom = vector2(screenSize.X / 2, screenSize.Y)
    elseif tracerOrigin == 'Cursor' then
        tracerFrom = UserInputService:GetMouseLocation()
    elseif tracerOrigin == 'Top Screen' then
        tracerFrom = vector2(screenSize.X / 2, 0)
    end
    for _, character in pairs(c_workspace:GetChildren()) do
        local actualPlayer = players:GetPlayerFromCharacter(character) or character
        if actualPlayer == player then continue end
        if not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
            clearTracer(character)
            continue
        end
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            clearTracer(character)
            continue
        end
        local team_attribute = actualPlayer:GetAttribute("Team")
        if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then
            clearTracer(character)
            continue
        end
        local targetHead = character:FindFirstChild("Head") or character.HumanoidRootPart
        local distance = (localRoot.Position - targetHead.Position).Magnitude
        if distance > espDistance then
            clearTracer(character)
            continue
        end
        if not tracerCache[character] then
            tracerCache[character] = createTracer(character)
        end
        local tracer = tracerCache[character]
        local headPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
        tracer.From = tracerFrom
        tracer.To = vector2(headPos.X, headPos.Y)
        tracer.Visible = onScreen
    end
end

local function updateChams()
    if not chamsEnabled then
        for character, _ in pairs(chamsCache) do
            clearChams(character)
        end
        return
    end
    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        for character, _ in pairs(chamsCache) do
            clearChams(character)
        end
        return
    end
    local localRoot = player.Character.HumanoidRootPart
    for _, character in pairs(c_workspace:GetChildren()) do
        local actualPlayer = players:GetPlayerFromCharacter(character) or character
        if actualPlayer == player then continue end
        if not character:FindFirstChild('HumanoidRootPart') or not character:FindFirstChild('Humanoid') then
            clearChams(character)
            continue
        end
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            clearChams(character)
            continue
        end
        local team_attribute = actualPlayer:GetAttribute("Team")
        if teamCheck and team_attribute and team_attribute == player:GetAttribute("Team") then
            clearChams(character)
            continue
        end
        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > espDistance then
            clearChams(character)
            continue
        end
        if not chamsCache[character] then
            chamsCache[character] = createChams(character)
        end
    end
end

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
ThemeManager:SetFolder('GunfightArenaX')
SaveManager:SetFolder('GunfightArenaX')
ThemeManager:SaveDefault('Tokyo Night')
local Window = Library:CreateWindow({
    Title = 'Gunfight Arena X | By zixy.py2',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Rage = Window:AddTab('Rage'),
    Visuals = Window:AddTab('Visuals'),
    Exploits = Window:AddTab('Exploits'),
    Weapons = Window:AddTab('Weapons'),
    Settings = Window:AddTab('Settings'),
}

local SilentAimGroup = Tabs.Rage:AddLeftGroupbox('Silent Aim Settings')
local FOVGroup = Tabs.Rage:AddRightGroupbox('FOV & Targeting')
SilentAimGroup:AddToggle('SilentWallbangToggle', {
    Text = 'Silent + Semi Wallbang',
    Default = false,
    Tooltip = 'Enables silent aim that sometimes shoots through walls',
    Callback = function(v) silentaim = v end
})
SilentAimGroup:AddToggle('RagebotToggle', {
    Text = 'Enable Ragebot',
    Default = false,
    Callback = function(Value)
        ragebotEnabled = Value
        if not ragebotEnabled and isRagebotShooting then
            mouse1release()
            isRagebotShooting = false
        end
    end
})
FOVGroup:AddToggle('FOVCircleToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(v) fovcircle = v end
})
FOVGroup:AddSlider('FOVRadiusSlider', {
    Text = 'FOV Radius',
    Default = 100,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(v) fovradius = v end
})
FOVGroup:AddDropdown('HitPartDropdown', {
    Text = 'Target Hit Part',
    Values = { "Head", "Torso", "HumanoidRootPart" },
    Default = "Head",
    Callback = function(v) hitpart = v end
})
FOVGroup:AddSlider('HitchanceSlider', {
    Text = 'Hitchance (%)',
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(v) hitchance = v end
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('Visual Controls')
VisualsGroup:AddToggle('ESPCustomToggle', {
    Text = 'Box ESP',
    Default = false,
    Callback = function(Value)
        espCustomEnabled = Value
        if not espCustomEnabled then
            for character, esp in pairs(espCache) do
                esp.Box.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('NameESPToggle', {
    Text = 'Name ESP',
    Default = false,
    Callback = function(Value)
        nameESPEnabled = Value
        if not nameESPEnabled then
            for character, esp in pairs(espCache) do
                esp.Name.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('DistanceESPToggle', {
    Text = 'Distance ESP',
    Default = false,
    Callback = function(Value)
        distanceESPEnabled = Value
        if not distanceESPEnabled then
            for character, esp in pairs(espCache) do
                esp.Distance.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('SkeletonESPToggle', {
    Text = 'Skeleton ESP',
    Default = false,
    Callback = function(Value)
        skeletonESPEnabled = Value
        if not skeletonESPEnabled then
            for character, _ in pairs(skeletonCache) do
                clearSkeleton(character)
            end
        end
    end
})
VisualsGroup:AddToggle('HealthESPToggle', {
    Text = 'Health ESP',
    Default = false,
    Callback = function(Value)
        healthESPEnabled = Value
        if not healthESPEnabled then
            for character, _ in pairs(healthCache) do
                clearHealthESP(character)
            end
        end
    end
})
VisualsGroup:AddToggle('TracerESPToggle', {
    Text = 'Tracer ESP',
    Default = false,
    Callback = function(Value)
        tracerESPEnabled = Value
        if not tracerESPEnabled then
            for character, _ in pairs(tracerCache) do
                clearTracer(character)
            end
        end
    end
})
VisualsGroup:AddToggle('ChamsToggle', {
    Text = 'Chams',
    Default = false,
    Callback = function(Value)
        chamsEnabled = Value
        if not chamsEnabled then
            for character, _ in pairs(chamsCache) do
                clearChams(character)
            end
        end
    end
})
VisualsGroup:AddToggle('TeamCheckToggle', {
    Text = 'Team Check',
    Default = false,
    Callback = function(Value)
        teamCheck = Value
    end
})
VisualsGroup:AddDropdown('TracerOriginDropdown', {
    Text = 'Tracer Origin',
    Default = tracerOrigin,
    Values = {'Bottom Screen', 'Cursor', 'Top Screen'},
    Callback = function(Value)
        tracerOrigin = Value
    end
})
local CombatExploitsGroup = Tabs.Exploits:AddLeftGroupbox('Combat Exploits')
CombatExploitsGroup:AddToggle('NoRecoilToggle', {
    Text = 'No Recoil',
    Default = false,
    Callback = function(v)
        norecoil = v
        removeRecoil()
    end
})
CombatExploitsGroup:AddToggle('InfiniteAmmoToggle', {
    Text = 'Infinite Ammo',
    Default = false,
    Callback = function(v) infiniteammo = v end
})
CombatExploitsGroup:AddToggle('NoForcefieldsToggle', {
    Text = 'Remove Enemy Forcefields',
    Default = false,
    Callback = function(v) noforcefields = v end
})
CombatExploitsGroup:AddButton({
    Text = 'Apply',
    Func = function()
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.Health = 0
        end
    end
})

local PrimaryGroup = Tabs.Weapons:AddLeftGroupbox('Primary Weapon')
local SecondaryGroup = Tabs.Weapons:AddRightGroupbox('Secondary Weapon')

PrimaryGroup:AddDropdown('PrimaryWeaponDropdown', {
    Default = weapons[1],
    Values = weapons,
    Callback = function(v) primary = v end
})
PrimaryGroup:AddDropdown('PrimaryCamoDropdown', {
    Text = 'Primary Camo',
    Default = camos[1],
    Values = camos,
    Callback = function(v) primarycamo = v end
})
PrimaryGroup:AddButton({
    Text = 'Apply Weapon',
    Func = function()
        player:SetAttribute("Primary", primary)
        player.Character.Humanoid.Health = 0
    end
})
PrimaryGroup:AddButton({
    Text = 'Apply Camo',
    Func = function()
        player:SetAttribute("PrimaryCamo", primarycamo)
        player.Character.Humanoid.Health = 0
    end
})
SecondaryGroup:AddDropdown('SecondaryWeaponDropdown', {
    Default = weapons[1],
    Values = weapons,
    Callback = function(v) secondary = v end
})
SecondaryGroup:AddDropdown('SecondaryCamoDropdown', {
    Text = 'Secondary Camo',
    Default = camos[1],
    Values = camos,
    Callback = function(v) secondarycamo = v end
})
SecondaryGroup:AddButton({
    Text = 'Apply Weapon',
    Func = function()
        player:SetAttribute("Secondary", secondary)
        player.Character.Humanoid.Health = 0
    end
})
SecondaryGroup:AddButton({
    Text = 'Apply Camo',
    Func = function()
        player:SetAttribute("SecondaryCamo", secondarycamo)
        player.Character.Humanoid.Health = 0
    end
})
local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end,
    Tooltip = 'Unloads the script',
})

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Text = 'Menu keybind:',
    Default = 'RightShift',
    NoUI = true,
})

Library.KeybindFrame.Visible = true
Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Gunfight Arena X | Made by zixy.py2')

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    fovCircle:Remove()
    aimbotFOVCircle:Remove()
    for character, _ in pairs(espCache) do clearESP(character) end
    for character, _ in pairs(skeletonCache) do clearSkeleton(character) end
    for character, _ in pairs(healthCache) do clearHealthESP(character) end
    for character, _ in pairs(tracerCache) do clearTracer(character) end
    for character, _ in pairs(chamsCache) do clearChams(character) end
    Library.Unloaded = true
end)

players.PlayerRemoving:Connect(function(character)
    clearESP(character)
    clearSkeleton(character)
    clearHealthESP(character)
    clearTracer(character)
    clearChams(character)
end)

players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function(character)
        character.AncestryChanged:Connect(function()
            if not character:IsDescendantOf(workspace) then
                clearESP(character)
                clearSkeleton(character)
                clearHealthESP(character)
                clearTracer(character)
                clearChams(character)
            end
        end)
        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.Died:Connect(function()
                clearESP(character)
                clearSkeleton(character)
                clearHealthESP(character)
                clearTracer(character)
                clearChams(character)
            end)
        end
    end)
end)

rs.RenderStepped:Connect(function()
    updateESP()
    updateSkeletonESP()
    updateHealthESP()
    updateTracerESP()
    updateChams()
end)
