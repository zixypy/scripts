local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local UserInputService = game:GetService('UserInputService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
ThemeManager:SetFolder('AimbloxX')
SaveManager:SetFolder('AimbloxX')
ThemeManager:SaveDefault('Tokyo Night')

local camera = Workspace.CurrentCamera
local players = Players
local LocalPlayer = players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local WorldToScreenPoint = camera.WorldToScreenPoint
local GetPlayers = Players.GetPlayers
local FindFirstChild = game.FindFirstChild

local Config = {
    HitPart = 'Head',
    TeamCheck = false,
    FOVColor = Color3.fromRGB(255, 255, 255),
    SilentAimFOVRadius = 100,
    SilentAimHitChance = 100,
    DistancePosition = 'Bottom',
}

local State = {
    SilentAimEnabled = false,
    SilentAimFOVEnabled = false,
    SilentAimFOVCircle = nil,
    WallbangEnabled = false,
    WallbangActive = false,
    OriginalCameraCFrame = nil,
    OriginalPlayerCFrame = nil,
    WallbangedPlayer = nil,
    OriginalFOVRadius = Config.SilentAimFOVRadius,
    VisualFOVRadius = Config.SilentAimFOVRadius,
    DotsEnabled = false,
    DotCache = {},
    DistanceEnabled = false,
    DistanceCache = {},
    FrameCounter = 0,
    MaxPlayersPerFrame = 10,
}

local function GetOnScreenPosition(V3)
    local Position, IsVisible = WorldToScreenPoint(camera, V3)
    return Vector2.new(Position.X, Position.Y), IsVisible
end

local function GetDirection(Origin, Position)
    return (Position - Origin).Unit * (Origin - Position).Magnitude
end

local function GetClosestPlayer()
    local Closest, Distance = nil, Config.SilentAimFOVRadius
    local MousePos = camera.ViewportSize / 2

    for _, Player in next, GetPlayers(Players) do
        if Player ~= LocalPlayer then
            local Character = Player.Character
            local HitPart = Character and FindFirstChild(Character, Config.HitPart)
            local Humanoid = Character and FindFirstChild(Character, "Humanoid")
            if HitPart and Humanoid and Humanoid.Health > 0 then
                local sameTeam = false
                if Config.TeamCheck then
                    if LocalPlayer.Team and Player.Team then
                        sameTeam = LocalPlayer.Team == Player.Team
                    elseif LocalPlayer.TeamColor and Player.TeamColor then
                        sameTeam = LocalPlayer.TeamColor == Player.TeamColor
                    elseif LocalPlayer:GetAttribute("Team") and Player:GetAttribute("Team") then
                        sameTeam = LocalPlayer:GetAttribute("Team") == Player:GetAttribute("Team")
                    end
                end
                if sameTeam then continue end
                local ScreenPos, IsVisible = GetOnScreenPosition(HitPart.Position)
                if IsVisible then
                    local _Distance = (MousePos - ScreenPos).Magnitude
                    if _Distance <= Distance then
                        Closest = HitPart
                        Distance = _Distance
                    end
                end
            end
        end
    end

    return Closest, Distance
end

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}

    if (State.SilentAimEnabled or State.WallbangActive) and Arguments[1] == Workspace and Method == "Raycast" then
        if typeof(Arguments[#Arguments]) ~= "RaycastParams" then
            return oldNamecall(...)
        end

        if State.SilentAimEnabled and math.random(1, 100) <= Config.SilentAimHitChance then
            local HitPart = GetClosestPlayer()
            if HitPart then
                Arguments[3] = GetDirection(Arguments[2], HitPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        elseif State.WallbangActive then
            local HitPart = GetClosestPlayer()
            if HitPart then
                Arguments[3] = GetDirection(Arguments[2], HitPart.Position)
                return oldNamecall(unpack(Arguments))
            end
        end
    end

    return oldNamecall(...)
end)

local function SafeExecute(func)
    local success, errorMessage = pcall(func)
    if not success then
        warn("Error in SafeExecute: " .. tostring(errorMessage))
    end
end

local function CreateFOVCircle()
    local circle = Drawing.new('Circle')
    circle.Thickness = 2
    circle.Color = Config.FOVColor
    circle.Filled = false
    circle.Transparency = 1
    circle.Visible = false
    circle.ZIndex = 1
    circle.Radius = State.VisualFOVRadius
    circle.Position = camera.ViewportSize / 2
    return circle
end

local function UpdateFOVCircle()
    if State.FrameCounter % 3 ~= 0 then return end
    if not State.SilentAimFOVCircle then
        State.SilentAimFOVCircle = CreateFOVCircle()
    end
    if not State.SilentAimFOVCircle then return end
    State.SilentAimFOVCircle.Position = camera.ViewportSize / 2
    State.SilentAimFOVCircle.Radius = State.VisualFOVRadius
    State.SilentAimFOVCircle.Visible = State.SilentAimFOVEnabled
end

local function CreateDot()
    local dot = Drawing.new('Circle')
    dot.Thickness = 1
    dot.Color = Color3.fromRGB(255, 0, 0)
    dot.Filled = true
    dot.Transparency = 1
    dot.Visible = false
    dot.ZIndex = 2
    dot.Radius = 5
    return dot
end

local function CreateDistanceText()
    local text = Drawing.new('Text')
    text.Size = 16
    text.Color = Color3.fromRGB(255, 255, 255)
    text.Outline = true
    text.Transparency = 1
    text.Visible = false
    text.ZIndex = 2
    text.Center = true
    return text
end

local function ClearDot(player)
    if State.DotCache[player] then
        State.DotCache[player]:Remove()
        State.DotCache[player] = nil
    end
end

local function ClearDistanceText(player)
    if State.DistanceCache[player] then
        State.DistanceCache[player]:Remove()
        State.DistanceCache[player] = nil
    end
end

local function UpdateVisuals()
    State.FrameCounter = State.FrameCounter + 1
    if State.FrameCounter % 3 ~= 0 then return end

    if not State.DotsEnabled and not State.DistanceEnabled then
        for player, _ in pairs(State.DotCache) do ClearDot(player) end
        for player, _ in pairs(State.DistanceCache) do ClearDistanceText(player) end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(State.DotCache) do ClearDot(player) end
        for player, _ in pairs(State.DistanceCache) do ClearDistanceText(player) end
        return
    end

    local closestHitPart = GetClosestPlayer()
    local closestPlayer = closestHitPart and Players:GetPlayerFromCharacter(closestHitPart.Parent)
    local playerCount = 0

    for _, player in ipairs(Players:GetPlayers()) do
        if playerCount >= State.MaxPlayersPerFrame then break end
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            ClearDot(player)
            ClearDistanceText(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            ClearDot(player)
            ClearDistanceText(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        if Config.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            ClearDot(player)
            ClearDistanceText(player)
            continue
        end

        local headPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position)
        local screenPos = Vector2.new(headPos.X, headPos.Y)
        playerCount = playerCount + 1

        if State.DotsEnabled then
            if not State.DotCache[player] then
                State.DotCache[player] = CreateDot()
            end
            local dot = State.DotCache[player]
            if onScreen then
                dot.Position = screenPos
                dot.Color = (player == closestPlayer) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                dot.Visible = true
            else
                dot.Visible = false
            end
        end

        if State.DistanceEnabled then
            if not State.DistanceCache[player] then
                State.DistanceCache[player] = CreateDistanceText()
            end
            local distanceText = State.DistanceCache[player]
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetRoot.Position).Magnitude
            distanceText.Text = string.format("%.1f studs", distance)
            if onScreen then
                local posY
                if Config.DistancePosition == 'Top' then
                    posY = screenPos.Y - 20
                elseif Config.DistancePosition == 'Mouse' then
                    posY = screenPos.Y
                else
                    posY = screenPos.Y + 20
                end
                distanceText.Position = Vector2.new(screenPos.X, posY)
                distanceText.Visible = true
            else
                distanceText.Visible = false
            end
        end
    end
end

local function HandleWallbangTeleport()
    if not State.WallbangEnabled or not State.WallbangActive or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        return
    end

    local ClosestHitPart = GetClosestPlayer()
    if ClosestHitPart and ClosestHitPart.Parent and ClosestHitPart.Parent:FindFirstChild('HumanoidRootPart') then
        local ClosestPlayer = Players:GetPlayerFromCharacter(ClosestHitPart.Parent) or ClosestHitPart.Parent
        State.WallbangedPlayer = ClosestPlayer
        local targetRoot = ClosestHitPart.Parent.HumanoidRootPart
        local forwardDirection = targetRoot.CFrame.LookVector
        local teleportPos = targetRoot.Position + (forwardDirection * -50)
        
        teleportPos = Vector3.new(teleportPos.X, targetRoot.Position.Y, teleportPos.Z)
        
        local rayOrigin = targetRoot.Position
        local rayDirection = forwardDirection * 10
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, ClosestHitPart.Parent}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        
        if raycastResult then
            local hitDistance = (raycastResult.Position - rayOrigin).Magnitude
            if hitDistance < 10 then
                teleportPos = rayOrigin + (forwardDirection * (hitDistance - 2))
                teleportPos = Vector3.new(teleportPos.X, targetRoot.Position.Y, teleportPos.Z)
            end
        end
        
        local targetPos = targetRoot.Position
        local lookDirection = (targetPos - teleportPos).Unit
        local flatLookDirection = Vector3.new(lookDirection.X, 0, lookDirection.Z).Unit
        local newCFrame = CFrame.new(teleportPos) * CFrame.new(Vector3.new(0, 0, 0), flatLookDirection)
        
        LocalPlayer.Character.HumanoidRootPart.CFrame = newCFrame
        
        local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.AutoRotate = false
        end
        
        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    else
        State.WallbangedPlayer = nil
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.AutoRotate = true
        end
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
end

local function UpdateCameraFreeze()
    if State.WallbangActive and State.OriginalCameraCFrame then
        camera.CFrame = State.OriginalCameraCFrame
    end
end

Players.PlayerRemoving:Connect(function(player)
    SafeExecute(function()
        ClearDot(player)
        ClearDistanceText(player)
        if player == State.WallbangedPlayer then
            State.WallbangedPlayer = nil
        end
    end)
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.Died:Connect(function()
                SafeExecute(function()
                    ClearDot(player)
                    ClearDistanceText(player)
                    if player == State.WallbangedPlayer then
                        State.WallbangedPlayer = nil
                    end
                end)
            end)
        end
    end)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 and State.WallbangEnabled then
        State.WallbangActive = true
        State.OriginalCameraCFrame = camera.CFrame
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
            State.OriginalPlayerCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame
        end
        State.OriginalFOVRadius = Config.SilentAimFOVRadius
        Config.SilentAimFOVRadius = Config.SilentAimFOVRadius * 10
        HandleWallbangTeleport()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 and State.WallbangEnabled then
        State.WallbangActive = false
        State.OriginalCameraCFrame = nil
        if State.OriginalPlayerCFrame and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
            LocalPlayer.Character.HumanoidRootPart.CFrame = State.OriginalPlayerCFrame
            State.OriginalPlayerCFrame = nil
        end
        State.WallbangedPlayer = nil
        Config.SilentAimFOVRadius = State.OriginalFOVRadius
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.AutoRotate = true
        end
    end
end)

local Window = Library:CreateWindow({
    Title = 'Aimblox X | By zixy.py2',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
})

local Tabs = {
    Rage = Window:AddTab('Rage'),
    Visuals = Window:AddTab('Visuals'),
    Settings = Window:AddTab('UI Settings'),
}

local RageGroup = Tabs.Rage:AddLeftGroupbox('Rage Controls')

RageGroup:AddToggle('SilentAimToggle', {
    Text = 'Enable Silent Aim',
    Default = false,
    Callback = function(Value)
        State.SilentAimEnabled = Value
    end,
})

RageGroup:AddToggle('SilentAimFOVToggle', {
    Text = 'Show FOV Circle',
    Default = false,
    Callback = function(Value)
        State.SilentAimFOVEnabled = Value
        if not State.SilentAimFOVEnabled and State.SilentAimFOVCircle then
            State.SilentAimFOVCircle.Visible = false
        end
    end,
})

RageGroup:AddSlider('SilentAimFOVSizeSlider', {
    Text = 'FOV Size',
    Default = Config.SilentAimFOVRadius,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        Config.SilentAimFOVRadius = Value
        State.OriginalFOVRadius = Value
        State.VisualFOVRadius = Value
    end,
})

RageGroup:AddDropdown('HitPartDropdown', {
    Text = 'Hit Part',
    Default = Config.HitPart,
    Values = {'Head', 'UpperTorso', 'LowerTorso', 'HumanoidRootPart'},
    Callback = function(Value)
        Config.HitPart = Value
    end,
})

RageGroup:AddSlider('SilentAimHitChanceSlider', {
    Text = 'Hit Chance (%)',
    Default = Config.SilentAimHitChance,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        Config.SilentAimHitChance = Value
    end,
})

RageGroup:AddToggle('WallbangToggle', {
    Text = 'Enable Wallbang (BUGGY)',
    Default = false,
    Callback = function(Value)
        State.WallbangEnabled = Value
        if not State.WallbangEnabled then
            State.WallbangActive = false
            State.OriginalCameraCFrame = nil
            State.OriginalPlayerCFrame = nil
            State.WallbangedPlayer = nil
            Config.SilentAimFOVRadius = State.OriginalFOVRadius
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
            if humanoid then
                humanoid.AutoRotate = true
            end
        end
    end,
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('Visual Controls')

VisualsGroup:AddToggle('DotsToggle', {
    Text = 'Enable Player Dots',
    Default = false,
    Callback = function(Value)
        State.DotsEnabled = Value
        if not State.DotsEnabled then
            for player, _ in pairs(State.DotCache) do
                ClearDot(player)
            end
        end
    end,
})

VisualsGroup:AddToggle('DistanceToggle', {
    Text = 'Enable Distance Display',
    Default = false,
    Callback = function(Value)
        State.DistanceEnabled = Value
        if not State.DistanceEnabled then
            for player, _ in pairs(State.DistanceCache) do
                ClearDistanceText(player)
            end
        end
    end,
})

VisualsGroup:AddDropdown('DistancePositionDropdown', {
    Text = 'Distance Position',
    Default = Config.DistancePosition,
    Values = {'Top', 'Bottom'},
    Callback = function(Value)
        Config.DistancePosition = Value
    end,
})

VisualsGroup:AddLabel('Team check broken :(')

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end,
    Tooltip = 'Unloads the script',
})

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind',
})

Library.ToggleKeybind = Options.MenuKeybind

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Aimblox X | Made by zixy.py2')

Library:OnUnload(function()
    if State.SilentAimFOVCircle then
        State.SilentAimFOVCircle:Remove()
    end
    for player, _ in pairs(State.DotCache) do
        ClearDot(player)
    end
    for player, _ in pairs(State.DistanceCache) do
        ClearDistanceText(player)
    end
    State.SilentAimEnabled = false
    State.SilentAimFOVEnabled = false
    State.WallbangEnabled = false
    State.WallbangActive = false
    State.OriginalCameraCFrame = nil
    State.OriginalPlayerCFrame = nil
    State.WallbangedPlayer = nil
    Config.SilentAimFOVRadius = State.OriginalFOVRadius
    State.DotsEnabled = false
    State.DistanceEnabled = false
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid')
    if humanoid then
        humanoid.AutoRotate = true
    end
    Library.Unloaded = true
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Library:Notify(
    'Cheat Loaded',
    'Aimblox X is ready! Press RightShift to toggle GUI.',
    5
)

RunService.RenderStepped:Connect(function()
    SafeExecute(UpdateFOVCircle)
    SafeExecute(UpdateVisuals)
    SafeExecute(UpdateCameraFreeze)
    SafeExecute(HandleWallbangTeleport)
end)
