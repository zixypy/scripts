local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
ThemeManager:SaveDefault('Tokyo Night')

local Window = Library:CreateWindow({
    Title = 'Airsoft Battles X | By zixy.py2',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Rage = Window:AddTab('Rage'),
    Visuals = Window:AddTab('Visuals'),
    Player = Window:AddTab('Player'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

local RageConfig = {
    SilentAimFOVRadius = 100,
    FOVColor = Color3.fromRGB(255, 255, 255),
}

local RageState = {
    SilentAimFOVCircle = nil,
}

local ESPSettings = {
    BoxEnabled = true,
    BoxColor = Color3.fromRGB(0, 64, 191),
    SkeletonESPColor = Color3.fromRGB(0, 64, 191),
    TracerColor = Color3.fromRGB(0, 64, 191),
    TracerOrigin = 'Bottom Screen',
}

local State = {
    ESPDistance = 1000,
    ESPCustomEnabled = false,
    NameESPEnabled = false,
    DistanceESPEnabled = false,
    SkeletonESPEnabled = false,
    HealthESPEnabled = false,
    TracerESPEnabled = false,
    WeaponESPEnabled = false,
    VisibleESPEnabled = false,
}

local Caches = {
    ESPCache = {},
    SkeletonCache = {},
    HealthCache = {},
    TracerCache = {},
}

local function GetWeaponName(character)
    if character then
        for _, v in ipairs(character:GetChildren()) do
            if v:IsA("Tool") then
                return v.Name
            end
        end
    end
    return "None"
end


local function isPartVisible(fromPos, toPart, targetCharacter)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Workspace.CurrentCamera}
    raycastParams.IgnoreWater = true

    local direction = (toPart.Position - fromPos).Unit * (toPart.Position - fromPos).Magnitude
    local raycastResult = Workspace:Raycast(fromPos, direction, raycastParams)

    if not raycastResult then
        return true
    end

    local hitInstance = raycastResult.Instance
    if hitInstance:IsDescendantOf(targetCharacter) or hitInstance == toPart then
        return true
    end

    if hitInstance.Transparency >= 0.9 or hitInstance.Material == Enum.Material.Glass then
        local newParams = RaycastParams.new()
        newParams.FilterType = Enum.RaycastFilterType.Blacklist
        newParams.FilterDescendantsInstances = {LocalPlayer.Character, Workspace.CurrentCamera, hitInstance}
        newParams.IgnoreWater = true

        local newResult = Workspace:Raycast(raycastResult.Position + direction.Unit * 0.1, direction, newParams)
        if not newResult or newResult.Instance:IsDescendantOf(targetCharacter) or newResult.Instance == toPart then
            return true
        end
    end

    return false
end

local function SafeExecute(func)
    local success, errorMessage = pcall(func)
    if not success then
        warn("Error in SafeExecute: " .. tostring(errorMessage))
    end
end

local function CreateSilentAimFOVCircle()
    local circle = Drawing.new('Circle')
    circle.Thickness = 2
    circle.Color = RageConfig.FOVColor
    circle.Filled = false
    circle.Transparency = 1
    circle.Visible = false
    circle.ZIndex = 1
    circle.Radius = RageConfig.SilentAimFOVRadius
    circle.Position = UIS:GetMouseLocation()
    return circle
end

local function UpdateSilentAimFOVCircle()
    if not RageState.SilentAimFOVCircle then
        RageState.SilentAimFOVCircle = CreateSilentAimFOVCircle()
    end

    RageState.SilentAimFOVCircle.Position = UIS:GetMouseLocation()
    RageState.SilentAimFOVCircle.Radius = RageConfig.SilentAimFOVRadius
    RageState.SilentAimFOVCircle.Visible = Toggles.SilentAimFOV.Value and 
        (Toggles.SilentAimEnabled.Value or Toggles.MagicBulletEnabled.Value or Toggles.KillAllEnabled.Value)
end

local function CreateESP(player)
    local esp = {
        Box = Drawing.new('Square'),
        Name = Drawing.new('Text'),
        Distance = Drawing.new('Text'),
        Weapon = Drawing.new('Text'),
        Visible = Drawing.new('Text'),
    }

    esp.Box.Thickness = 2
    esp.Box.Color = ESPSettings.BoxColor
    esp.Box.Filled = false
    esp.Box.Visible = false

    esp.Name.Size = 16
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Outline = true
    esp.Name.Center = true
    esp.Name.Visible = false

    esp.Distance.Size = 16
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Outline = true
    esp.Distance.Center = true
    esp.Distance.Visible = false

    esp.Weapon.Size = 16
    esp.Weapon.Color = Color3.new(1, 1, 1)
    esp.Weapon.Outline = true
    esp.Weapon.Center = true
    esp.Weapon.Visible = false

    esp.Visible.Size = 16
    esp.Visible.Color = Color3.new(1, 1, 1)
    esp.Visible.Outline = true
    esp.Visible.Center = true
    esp.Visible.Visible = false

    return esp
end

local function CreateSkeleton(player)
    local skeleton = {
        HeadToNeck = Drawing.new('Line'),
        NeckToUpperTorso = Drawing.new('Line'),
        UpperTorsoToLowerTorso = Drawing.new('Line'),
        UpperTorsoToLeftUpperArm = Drawing.new('Line'),
        LeftUpperArmToLeftLowerArm = Drawing.new('Line'),
        LeftLowerArmToLeftHand = Drawing.new('Line'),
        UpperTorsoToRightUpperArm = Drawing.new('Line'),
        RightUpperArmToRightLowerArm = Drawing.new('Line'),
        RightLowerArmToRightHand = Drawing.new('Line'),
        LowerTorsoToLeftUpperLeg = Drawing.new('Line'),
        LeftUpperLegToLeftLowerLeg = Drawing.new('Line'),
        LeftLowerLegToLeftFoot = Drawing.new('Line'),
        LowerTorsoToRightUpperLeg = Drawing.new('Line'),
        RightUpperLegToRightLowerLeg = Drawing.new('Line'),
        RightLowerLegToRightFoot = Drawing.new('Line'),
    }

    for _, line in pairs(skeleton) do
        line.Thickness = 2
        line.Color = ESPSettings.SkeletonESPColor
        line.Visible = false
    end

    return skeleton
end

local function CreateHealthESP(player)
    local health = {
        BarBackground = Drawing.new('Square'),
        Bar = Drawing.new('Square'),
        Text = Drawing.new('Text'),
    }

    health.BarBackground.Size = Vector2.new(50, 5)
    health.BarBackground.Color = Color3.new(0, 0, 0)
    health.BarBackground.Filled = true
    health.BarBackground.Transparency = 0.5
    health.BarBackground.Visible = false

    health.Bar.Size = Vector2.new(50, 5)
    health.Bar.Color = Color3.new(0, 1, 0)
    health.Bar.Filled = true
    health.Bar.Visible = false

    health.Text.Size = 12
    health.Text.Color = Color3.new(1, 1, 1)
    health.Text.Outline = true
    health.Text.Center = true
    health.Text.Visible = false

    return health
end

local function CreateTracer(player)
    local tracer = Drawing.new('Line')
    tracer.Thickness = 2
    tracer.Color = ESPSettings.TracerColor
    tracer.Visible = false
    return tracer
end


local function ClearESP(player)
    if Caches.ESPCache[player] then
        Caches.ESPCache[player].Box:Remove()
        Caches.ESPCache[player].Name:Remove()
        Caches.ESPCache[player].Distance:Remove()
        Caches.ESPCache[player].Weapon:Remove()
        Caches.ESPCache[player].Visible:Remove()
        Caches.ESPCache[player] = nil
    end
end

local function ClearSkeleton(player)
    if Caches.SkeletonCache[player] then
        for _, line in pairs(Caches.SkeletonCache[player]) do
            line:Remove()
        end
        Caches.SkeletonCache[player] = nil
    end
end

local function ClearHealthESP(player)
    if Caches.HealthCache[player] then
        Caches.HealthCache[player].BarBackground:Remove()
        Caches.HealthCache[player].Bar:Remove()
        Caches.HealthCache[player].Text:Remove()
        Caches.HealthCache[player] = nil
    end
end

local function ClearTracer(player)
    if Caches.TracerCache[player] then
        Caches.TracerCache[player]:Remove()
        Caches.TracerCache[player] = nil
    end
end


local function UpdateESP()
    if not (State.ESPCustomEnabled or State.NameESPEnabled or State.DistanceESPEnabled or State.WeaponESPEnabled or State.VisibleESPEnabled) then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.ESPCache) do
            ClearESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            ClearESP(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            ClearESP(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > State.ESPDistance then
            ClearESP(player)
            continue
        end

        if Toggles.TeamCheckRage.Value and LocalPlayer:GetAttribute("Team") and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then
            ClearESP(player)
            continue
        end

        if not Caches.ESPCache[player] then
            Caches.ESPCache[player] = CreateESP(player)
        end

        local esp = Caches.ESPCache[player]
        local rootPos, onScreen = Camera:WorldToViewportPoint(targetRoot.Position)
        if onScreen then
            local head = character:FindFirstChild("Head")
            local topPos = head and Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1, 0)) or Camera:WorldToViewportPoint(targetRoot.Position + Vector3.new(0, 3, 0))
            local bottomPos = Camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
            local height = math.abs(topPos.Y - bottomPos.Y)
            local width = height * 0.5
            local centerPos = Vector2.new(rootPos.X, (topPos.Y + bottomPos.Y) / 2)
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = centerPos - Vector2.new(width / 2, height / 2)
            esp.Box.Visible = ESPSettings.BoxEnabled and State.ESPCustomEnabled
            esp.Name.Text = player.Name
            esp.Name.Position = Vector2.new(rootPos.X, topPos.Y - 20)
            esp.Name.Visible = State.NameESPEnabled
            esp.Distance.Text = tostring(math.floor(distance)) .. " studs"
            esp.Distance.Position = Vector2.new(rootPos.X, bottomPos.Y + 5)
            esp.Distance.Visible = State.DistanceESPEnabled
            esp.Weapon.Text = GetWeaponName(character)
            esp.Weapon.Position = Vector2.new(rootPos.X, bottomPos.Y + 20)
            esp.Weapon.Visible = State.WeaponESPEnabled
            esp.Visible.Text = head and isPartVisible(Camera.CFrame.Position, head, character) and "Visible" or "Not Visible"
            esp.Visible.Position = Vector2.new(rootPos.X, topPos.Y - 35)
            esp.Visible.Visible = State.VisibleESPEnabled
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
            esp.Weapon.Visible = false
            esp.Visible.Visible = false
        end
    end
end

local function UpdateSkeletonESP()
    if not State.SkeletonESPEnabled then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.SkeletonCache) do
            ClearSkeleton(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            ClearSkeleton(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            ClearSkeleton(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > State.ESPDistance then
            ClearSkeleton(player)
            continue
        end

        if Toggles.TeamCheckRage.Value and LocalPlayer:GetAttribute("Team") and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then
            ClearSkeleton(player)
            continue
        end

        if not Caches.SkeletonCache[player] then
            Caches.SkeletonCache[player] = CreateSkeleton(player)
        end

        local skeleton = Caches.SkeletonCache[player]
        local parts = {
            Head = character:FindFirstChild("Head"),
            Neck = character:FindFirstChild("Head"),
            UpperTorso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
            LowerTorso = character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso"),
            LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
            LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
            LeftHand = character:FindFirstChild("LeftHand"),
            RightUpperArm = character:FindFirstChild("RightUpperArm"),
            RightLowerArm = character:FindFirstChild("RightLowerArm"),
            RightHand = character:FindFirstChild("RightHand"),
            LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
            LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
            LeftFoot = character:FindFirstChild("LeftFoot"),
            RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
            RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
            RightFoot = character:FindFirstChild("RightFoot"),
        }

        if not (parts.Head and parts.UpperTorso and parts.LowerTorso and parts.LeftUpperArm and parts.LeftLowerArm and parts.LeftHand and parts.RightUpperArm and parts.RightLowerArm and parts.RightHand and parts.LeftUpperLeg and parts.LeftLowerLeg and parts.LeftFoot and parts.RightUpperLeg and parts.RightLowerLeg and parts.RightFoot) then
            ClearSkeleton(player)
            continue
        end

        local headPos, headOnScreen = Camera:WorldToViewportPoint(parts.Head.Position)
        local neckPos, neckOnScreen = Camera:WorldToViewportPoint(parts.Neck.Position)
        local upperTorsoPos, upperTorsoOnScreen = Camera:WorldToViewportPoint(parts.UpperTorso.Position)
        local lowerTorsoPos, lowerTorsoOnScreen = Camera:WorldToViewportPoint(parts.LowerTorso.Position)
        local leftUpperArmPos, leftUpperArmOnScreen = Camera:WorldToViewportPoint(parts.LeftUpperArm.Position)
        local leftLowerArmPos, leftLowerArmOnScreen = Camera:WorldToViewportPoint(parts.LeftLowerArm.Position)
        local leftHandPos, leftHandOnScreen = Camera:WorldToViewportPoint(parts.LeftHand.Position)
        local rightUpperArmPos, rightUpperArmOnScreen = Camera:WorldToViewportPoint(parts.RightUpperArm.Position)
        local rightLowerArmPos, rightLowerArmOnScreen = Camera:WorldToViewportPoint(parts.RightLowerArm.Position)
        local rightHandPos, rightHandOnScreen = Camera:WorldToViewportPoint(parts.RightHand.Position)
        local leftUpperLegPos, leftUpperLegOnScreen = Camera:WorldToViewportPoint(parts.LeftUpperLeg.Position)
        local leftLowerLegPos, leftLowerLegOnScreen = Camera:WorldToViewportPoint(parts.LeftLowerLeg.Position)
        local leftFootPos, leftFootOnScreen = Camera:WorldToViewportPoint(parts.LeftFoot.Position)
        local rightUpperLegPos, rightUpperLegOnScreen = Camera:WorldToViewportPoint(parts.RightUpperLeg.Position)
        local rightLowerLegPos, rightLowerLegOnScreen = Camera:WorldToViewportPoint(parts.RightLowerLeg.Position)
        local rightFootPos, rightFootOnScreen = Camera:WorldToViewportPoint(parts.RightFoot.Position)

        if headOnScreen and neckOnScreen then
            skeleton.HeadToNeck.From = Vector2.new(headPos.X, headPos.Y)
            skeleton.HeadToNeck.To = Vector2.new(neckPos.X, neckPos.Y)
            skeleton.HeadToNeck.Visible = true
        else
            skeleton.HeadToNeck.Visible = false
        end

        if neckOnScreen and upperTorsoOnScreen then
            skeleton.NeckToUpperTorso.From = Vector2.new(neckPos.X, neckPos.Y)
            skeleton.NeckToUpperTorso.To = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.NeckToUpperTorso.Visible = true
        else
            skeleton.NeckToUpperTorso.Visible = false
        end

        if upperTorsoOnScreen and lowerTorsoOnScreen then
            skeleton.UpperTorsoToLowerTorso.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.To = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.Visible = true
        else
            skeleton.UpperTorsoToLowerTorso.Visible = false
        end

        if upperTorsoOnScreen and leftUpperArmOnScreen then
            skeleton.UpperTorsoToLeftUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.To = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.Visible = true
        else
            skeleton.UpperTorsoToLeftUpperArm.Visible = false
        end

        if leftUpperArmOnScreen and leftLowerArmOnScreen then
            skeleton.LeftUpperArmToLeftLowerArm.From = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.To = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.Visible = true
        else
            skeleton.LeftUpperArmToLeftLowerArm.Visible = false
        end

        if leftLowerArmOnScreen and leftHandOnScreen then
            skeleton.LeftLowerArmToLeftHand.From = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftLowerArmToLeftHand.To = Vector2.new(leftHandPos.X, leftHandPos.Y)
            skeleton.LeftLowerArmToLeftHand.Visible = true
        else
            skeleton.LeftLowerArmToLeftHand.Visible = false
        end

        if upperTorsoOnScreen and rightUpperArmOnScreen then
            skeleton.UpperTorsoToRightUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToRightUpperArm.To = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.UpperTorsoToRightUpperArm.Visible = true
        else
            skeleton.UpperTorsoToRightUpperArm.Visible = false
        end

        if rightUpperArmOnScreen and rightLowerArmOnScreen then
            skeleton.RightUpperArmToRightLowerArm.From = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.To = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.Visible = true
        else
            skeleton.RightUpperArmToRightLowerArm.Visible = false
        end

        if rightLowerArmOnScreen and rightHandOnScreen then
            skeleton.RightLowerArmToRightHand.From = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightLowerArmToRightHand.To = Vector2.new(rightHandPos.X, rightHandPos.Y)
            skeleton.RightLowerArmToRightHand.Visible = true
        else
            skeleton.RightLowerArmToRightHand.Visible = false
        end

        if lowerTorsoOnScreen and leftUpperLegOnScreen then
            skeleton.LowerTorsoToLeftUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.To = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.Visible = true
        else
            skeleton.LowerTorsoToLeftUpperLeg.Visible = false
        end

        if leftUpperLegOnScreen and leftLowerLegOnScreen then
            skeleton.LeftUpperLegToLeftLowerLeg.From = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.To = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = true
        else
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = false
        end

        if leftLowerLegOnScreen and leftFootOnScreen then
            skeleton.LeftLowerLegToLeftFoot.From = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftLowerLegToLeftFoot.To = Vector2.new(leftFootPos.X, leftFootPos.Y)
            skeleton.LeftLowerLegToLeftFoot.Visible = true
        else
            skeleton.LeftLowerLegToLeftFoot.Visible = false
        end

        if lowerTorsoOnScreen and rightUpperLegOnScreen then
            skeleton.LowerTorsoToRightUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.To = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.Visible = true
        else
            skeleton.LowerTorsoToRightUpperLeg.Visible = false
        end

        if rightUpperLegOnScreen and rightLowerLegOnScreen then
            skeleton.RightUpperLegToRightLowerLeg.From = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.To = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.Visible = true
        else
            skeleton.RightUpperLegToRightLowerLeg.Visible = false
        end

        if rightLowerLegOnScreen and rightFootOnScreen then
            skeleton.RightLowerLegToRightFoot.From = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightLowerLegToRightFoot.To = Vector2.new(rightFootPos.X, rightFootPos.Y)
            skeleton.RightLowerLegToRightFoot.Visible = true
        else
            skeleton.RightLowerLegToRightFoot.Visible = false
        end
    end
end

local function UpdateHealthESP()
    if not State.HealthESPEnabled then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.HealthCache) do
            ClearHealthESP(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            ClearHealthESP(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            ClearHealthESP(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > State.ESPDistance then
            ClearHealthESP(player)
            continue
        end

        if Toggles.TeamCheckRage.Value and LocalPlayer:GetAttribute("Team") and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then
            ClearHealthESP(player)
            continue
        end

        if not Caches.HealthCache[player] then
            Caches.HealthCache[player] = CreateHealthESP(player)
        end

        local health = Caches.HealthCache[player]
        local headPos, onScreen = Camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
        if onScreen then
            local healthPercentage = humanoid.Health / humanoid.MaxHealth
            health.BarBackground.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
            health.BarBackground.Visible = true
            health.Bar.Size = Vector2.new(50 * healthPercentage, 5)
            health.Bar.Position = Vector2.new(headPos.X - 25, headPos.Y - 30)
            health.Bar.Color = Color3.new(1 - healthPercentage, healthPercentage, 0)
            health.Bar.Visible = true
            health.Text.Text = tostring(math.floor(healthPercentage * 100)) .. "%"
            health.Text.Position = Vector2.new(headPos.X, headPos.Y - 45)
            health.Text.Visible = true
        else
            health.BarBackground.Visible = false
            health.Bar.Visible = false
            health.Text.Visible = false
        end
    end
end

local function UpdateTracerESP()
    if not State.TracerESPEnabled then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(Caches.TracerCache) do
            ClearTracer(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    local screenSize = Camera.ViewportSize
    local tracerFrom
    if ESPSettings.TracerOrigin == 'Bottom Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, screenSize.Y)
    elseif ESPSettings.TracerOrigin == 'Cursor' then
        tracerFrom = UIS:GetMouseLocation()
    elseif ESPSettings.TracerOrigin == 'Top Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, 0)
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            ClearTracer(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            ClearTracer(player)
            continue
        end

        local targetHead = character:FindFirstChild("Head") or character.HumanoidRootPart
        local distance = (localRoot.Position - targetHead.Position).Magnitude
        if distance > State.ESPDistance then
            ClearTracer(player)
            continue
        end

        if Toggles.TeamCheckRage.Value and LocalPlayer:GetAttribute("Team") and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then
            ClearTracer(player)
            continue
        end

        if not Caches.TracerCache[player] then
            Caches.TracerCache[player] = CreateTracer(player)
        end

        local tracer = Caches.TracerCache[player]
        local headPos, onScreen = Camera:WorldToViewportPoint(targetHead.Position)
        tracer.From = tracerFrom
        tracer.To = Vector2.new(headPos.X, headPos.Y)
        tracer.Visible = onScreen
    end
end



local RageGroup = Tabs.Rage:AddLeftGroupbox('Silent Aim')
RageGroup:AddToggle('TeamCheckRage', {
    Text = 'Team Check',
    Default = true,
    Callback = function(Value) end
})
RageGroup:AddToggle('SilentAimEnabled', {
    Text = 'Silent Aim (Visible Check)',
    Default = false,
    Callback = function(Value) end
})
RageGroup:AddToggle('SilentAimFOV', {
    Text = 'Enable FOV Circle',
    Default = true,
    Callback = function(Value)
        if RageState.SilentAimFOVCircle then
            RageState.SilentAimFOVCircle.Visible = Value and 
                (Toggles.SilentAimEnabled.Value or Toggles.MagicBulletEnabled.Value or Toggles.KillAllEnabled.Value)
        end
    end
})
RageGroup:AddSlider('SilentAimFOVSizeSlider', {
    Text = 'FOV Size',
    Default = RageConfig.SilentAimFOVRadius,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Suffix = '',
    Callback = function(Value)
        RageConfig.SilentAimFOVRadius = Value
    end
})
RageGroup:AddDropdown('SilentAimHitpart', {
    Text = 'Hitpart',
    Values = {'Head', 'Torso', 'Random'},
    Default = 1,
    Callback = function(Value) end
})
RageGroup:AddToggle('MagicBulletEnabled', {
    Text = 'Magic Bullet (No Visible Check)',
    Default = false,
    Callback = function(Value) end
})
RageGroup:AddToggle('KillAllEnabled', {
    Text = 'Kill All',
    Default = false,
    Callback = function(Value)
        if RageState.SilentAimFOVCircle then
            RageState.SilentAimFOVCircle.Visible = Toggles.SilentAimFOV.Value and 
                (Toggles.SilentAimEnabled.Value or Toggles.MagicBulletEnabled.Value or Value)
        end
    end
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox('ESP')
VisualsGroup:AddToggle('ESPCustomToggle', {
    Text = 'Box ESP',
    Default = false,
    Callback = function(Value)
        State.ESPCustomEnabled = Value
        if not State.ESPCustomEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Box.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('NameESPToggle', {
    Text = 'Name ESP',
    Default = false,
    Callback = function(Value)
        State.NameESPEnabled = Value
        if not State.NameESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Name.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('DistanceESPToggle', {
    Text = 'Distance ESP',
    Default = false,
    Callback = function(Value)
        State.DistanceESPEnabled = Value
        if not State.DistanceESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Distance.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('SkeletonESPToggle', {
    Text = 'Skeleton ESP',
    Default = false,
    Callback = function(Value)
        State.SkeletonESPEnabled = Value
        if not State.SkeletonESPEnabled then
            for player, _ in pairs(Caches.SkeletonCache) do
                ClearSkeleton(player)
            end
        end
    end
})
VisualsGroup:AddToggle('HealthESPToggle', {
    Text = 'Health ESP',
    Default = false,
    Callback = function(Value)
        State.HealthESPEnabled = Value
        if not State.HealthESPEnabled then
            for player, _ in pairs(Caches.HealthCache) do
                ClearHealthESP(player)
            end
        end
    end
})
VisualsGroup:AddToggle('TracerESPToggle', {
    Text = 'Tracer ESP',
    Default = false,
    Callback = function(Value)
        State.TracerESPEnabled = Value
        if not State.TracerESPEnabled then
            for player, _ in pairs(Caches.TracerCache) do
                ClearTracer(player)
            end
        end
    end
})
VisualsGroup:AddToggle('WeaponESPToggle', {
    Text = 'Weapon ESP',
    Default = false,
    Callback = function(Value)
        State.WeaponESPEnabled = Value
        if not State.WeaponESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Weapon.Visible = false
            end
        end
    end
})
VisualsGroup:AddToggle('VisibleESPToggle', {
    Text = 'Visible ESP',
    Default = false,
    Callback = function(Value)
        State.VisibleESPEnabled = Value
        if not State.VisibleESPEnabled then
            for player, esp in pairs(Caches.ESPCache) do
                esp.Visible.Visible = false
            end
        end
    end
})

VisualsGroup:AddDropdown('TracerOriginDropdown', {
    Text = 'Tracer Origin',
    Default = ESPSettings.TracerOrigin,
    Values = {'Bottom Screen', 'Cursor', 'Top Screen'},
    Callback = function(Value)
        ESPSettings.TracerOrigin = Value
    end
})

local PlayerGroup = Tabs.Player:AddLeftGroupbox('Player Modifications')
PlayerGroup:AddToggle('FlyEnabled', {
    Text = 'Fly',
    Default = false,
    Callback = function(Value) end
})
PlayerGroup:AddSlider('FlySpeed', {
    Text = 'Fly Speed',
    Default = 50,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Callback = function(Value) end
})
PlayerGroup:AddToggle('WalkspeedEnabled', {
    Text = 'Walkspeed',
    Default = false,
    Callback = function(Value) end
})
PlayerGroup:AddSlider('WalkspeedValue', {
    Text = 'Walkspeed Value',
    Default = 16,
    Min = 16,
    Max = 500,
    Rounding = 0,
    Callback = function(Value) end
})
PlayerGroup:AddToggle('JumpHeightEnabled', {
    Text = 'Jump Height',
    Default = false,
    Callback = function(Value) end
})
PlayerGroup:AddSlider('JumpHeightValue', {
    Text = 'Jump Height Value',
    Default = 50,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(Value) end
})
PlayerGroup:AddToggle('NoclipEnabled', {
    Text = 'Noclip',
    Default = false,
    Callback = function(Value) end
})

local function GetClosestPlayer(fovRadius, teamCheck, ignoreTeamForMagicBullet)
    local closestPlayer = nil
    local shortestDistance = fovRadius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and 
           player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            if teamCheck and not ignoreTeamForMagicBullet and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then 
                continue 
            end
            local headPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local distance = (Vector2.new(headPos.X, headPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if distance <= shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

local function FireSilentAim(target, hitpart, visibleCheck, teamCheck, ignoreTeamForMagicBullet)
    if not LocalPlayer.Character or not target.Character then return end
    if teamCheck and not ignoreTeamForMagicBullet and target:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then return end
    local WeaponName = GetWeaponName(LocalPlayer.Character)
    if not WeaponName then return end

    local part = hitpart == "Random" and (math.random() > 0.5 and "Head" or "Torso") or hitpart
    local targetPart = target.Character:FindFirstChild(part)
    local humanoid = target.Character:FindFirstChild("Humanoid")
    if not targetPart or not humanoid or humanoid.Health <= 0 then return end

    if visibleCheck and not isPartVisible(Camera.CFrame.Position, targetPart, target.Character) then return end

    local BulletID = LocalPlayer.Name .. LocalPlayer.UserId .. tick() .. math.random(111, 999) .. math.random(111, 999)
    RS.ACS_Engine.Events.ServerBullet:FireServer({
        targetPart.Position,
        Vector3.new(0, 0, 0),
        {
            origin = targetPart.Position,
            weaponName = WeaponName,
            bulletID = BulletID,
            currentPenetrationCount = 0,
            shellSpeed = 1,
            maxPenetrationCount = 1,
            penetrationMultiplier = 1,
            shellType = "Bullet",
            shellMaxDist = 1,
            filterDescendants = { LocalPlayer.Character, Workspace.Camera },
        }
    })

    RS.ACS_Engine.Events.Damage:InvokeServer(unpack({
        {
            origin = targetPart.Position,
            weaponName = WeaponName,
            bulletID = BulletID,
            currentPenetrationCount = 0,
            shellSpeed = 1,
            maxPenetrationCount = 1,
            registeredParts = { [targetPart] = true },
            penetrationMultiplier = 1,
            shellType = "Bullet",
            shellMaxDist = 1,
            filterDescendants = { LocalPlayer.Character, Workspace.Camera.Viewmodel }
        },
        humanoid,
        200,
        2,
        targetPart,
        1
    }))
end

local function KillAll()
    while Toggles.KillAllEnabled.Value do
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and
               player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
                if Toggles.TeamCheckRage.Value and player:GetAttribute("Team") == LocalPlayer:GetAttribute("Team") then 
                    continue 
                end
                FireSilentAim(player, Options.SilentAimHitpart.Value, false, Toggles.TeamCheckRage.Value, false)
            end
        end
        task.wait(0.1)
    end
end

local function Fly()
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Parent = LocalPlayer.Character.HumanoidRootPart
    while Toggles.FlyEnabled.Value and LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart do
        local moveDir = Vector3.new()
        if UIS:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + Camera.CFrame.LookVector end
        if UIS:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - Camera.CFrame.LookVector end
        if UIS:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - Camera.CFrame.RightVector end
        if UIS:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + Camera.CFrame.RightVector end
        if UIS:IsKeyDown(Enum.KeyCode.Space) then moveDir = moveDir + Vector3.new(0, 1, 0) end
        if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then moveDir = moveDir - Vector3.new(0, 1, 0) end
        bodyVelocity.Velocity = moveDir * Options.FlySpeed.Value
        RunService.Heartbeat:Wait()
    end
    bodyVelocity:Destroy()
end

local function UpdateWalkspeed()
    if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
        LocalPlayer.Character.Humanoid.WalkSpeed = Toggles.WalkspeedEnabled.Value and Options.WalkspeedValue.Value or 16
    end
end

local function UpdateJumpHeight()
    if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
        LocalPlayer.Character.Humanoid.JumpPower = Toggles.JumpHeightEnabled.Value and Options.JumpHeightValue.Value or 50
    end
end

local function Noclip()
    while Toggles.NoclipEnabled.Value and LocalPlayer.Character do
        for _, part in ipairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        RunService.Stepped:Wait()
    end
end

Players.PlayerRemoving:Connect(function(player)
    SafeExecute(function()
        ClearESP(player)
        ClearSkeleton(player)
        ClearHealthESP(player)
        ClearTracer(player)
    end)
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        character.AncestryChanged:Connect(function()
            if not character:IsDescendantOf(Workspace) then
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end)
            end
        end)
        local humanoid = character:FindFirstChild('Humanoid')
        if humanoid then
            humanoid.Died:Connect(function()
                SafeExecute(function()
                    ClearESP(player)
                    ClearSkeleton(player)
                    ClearHealthESP(player)
                    ClearTracer(player)
                end)
            end)
        end
    end)
end)

RunService.RenderStepped:Connect(function()
    SafeExecute(UpdateSilentAimFOVCircle)
    SafeExecute(UpdateESP)
    SafeExecute(UpdateSkeletonESP)
    SafeExecute(UpdateHealthESP)
    SafeExecute(UpdateTracerESP)
    UpdateWalkspeed()
    UpdateJumpHeight()

    if (Toggles.SilentAimEnabled.Value or Toggles.MagicBulletEnabled.Value) and
       UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
        local target = GetClosestPlayer(
            RageConfig.SilentAimFOVRadius, 
            Toggles.TeamCheckRage.Value, 
            Toggles.MagicBulletEnabled.Value
        )
        if target and target.Character then
            FireSilentAim(
                target, 
                Options.SilentAimHitpart.Value, 
                Toggles.SilentAimEnabled.Value and not Toggles.MagicBulletEnabled.Value, 
                Toggles.TeamCheckRage.Value, 
                Toggles.MagicBulletEnabled.Value
            )
        end
    end
end)

Toggles.FlyEnabled:OnChanged(function()
    if Toggles.FlyEnabled.Value then
        task.spawn(Fly)
    end
end)
Toggles.NoclipEnabled:OnChanged(function()
    if Toggles.NoclipEnabled.Value then
        task.spawn(Noclip)
    end
end)
Toggles.KillAllEnabled:OnChanged(function()
    if Toggles.KillAllEnabled.Value then
        task.spawn(KillAll)
    end
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'RightShift', NoUI = true, Text = 'Menu keybind' })
Library.ToggleKeybind = Options.MenuKeybind
Library:SetWatermarkVisibility(true)
Library:SetWatermark('Airsoft Battles X | Made by zixy.py2')
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('AirsoftBattlesX')
SaveManager:SetFolder('AirsoftBattlesX/game')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()
